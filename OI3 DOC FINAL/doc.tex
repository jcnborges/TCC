\documentclass[12pt, a4paper]{article}
\usepackage[brazilian]{babel} % pt-BR
\usepackage[latin1]{inputenc} % Para aceitar os caracteres com acento
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[final]{pdfpages}
\usepackage{graphicx} % Trabalhar com imagens
\usepackage{float}
%\usepackage[center,small]{caption} % Legendas centralizadas e com fonte menor
\usepackage[pdfborder={0 0 0}]{hyperref} % Hyperlinks nas referencias (sem borda)
\usepackage{amsmath}
\usepackage{listings}


\begin{document}

\includepdf[pages={1,2}]{capa.pdf}
\tableofcontents % Sumario
\newpage

\listoffigures % Lista de Figuras
\newpage

\section{Introdução}
\subsection{Resumo}
Este trabalho descreve o planejamento e a realização do projeto Bellator, que visou implementar mais algumas funcionalidades para a já existente plataforma robótica Bellator. O foco do projeto realizado por esta equipe foi, partindo do trabalho já realizado na plataforma anteriormente, a implementação de um software supervisor remoto em linguagem Java que permitisse que o robô fosse controlado remotamente via wireless através de um joystick ligado a um PC. Além disso, o software disponibiliza para a navegação a imagem da webcam e os dados de sensores de distância instalados no robô. O projeto também incluiu uma adaptação do controle de mais baixo nível do robô, realizado por uma placa com processador 8051, para que fossem adicionados mais sensores de distância, proporcionando um melhor controle da situação do robô para o usuário do supervisor remoto.

\subsection{Abstract}
This paper describes the planning and execution of the Bellator project, which aimed to implement some more features to the existing robotic plataform Bellator. The focus of the project undertaken by this team was, starting with the work previously done on the robotic plataform, the software implementation of a remote supervisor in the Java programming language, which allowed the robot to be remotely controlled by a joystick connected to a PC via wireless. In addition, the software provides navigation aid through the webcam image and the data from the distance sensors installed on the robot. The project also included an adaptation of the lower level control of the robot, done by 8051 processor, to add more distance sensors, providing better navigation of the robot to the user of the remote supervisor.

\subsection{Objetivos}

Contribuir para o aprimoramento da plataforma robótica Bellator, para tal realizar as seguintes tarefas:

\begin{itemize}

\item Migrar o controle da camada de baixo nível do robô da placa atual para a C8051F340DK.

\item Adicionar ao robô 6 novos sensores ópticos.

\item Desenvolver um software para a camada supervisória do robô que permita que este seja controlado remotamente.

\item Documentar todo o trabalho realizado adequadamente para que possa ter continuidade no futuro.

\end{itemize}

\subsection{Motivação e Justificativa}
A maior motivação para a realização deste trabalho é, tendo em vista o contexto de sua realização, o aprendizado. No caso específico da disciplina para a qual o projeto está sendo realizado, este aprendizado refere-se não apenas aos conteúdos adquiridos na implementação dos produtos propostos mas, também, aprendizado sobre planejamento e gerenciamento de projeto. A equipe tem também o desafio de realizar um projeto partindo do trabalho realizado por várias outras pessoas, e que na maior parte das vezes não foi muito bem documentado. Conhecendo essas dificuldades, é dever da equipe finalizar o projeto deixando uma documentação muito melhor do que a encontrada, visto que a plataforma Bellator tem potencial para abrigar muitos outros projetos no futuro.

Assim, a justificativa para a realização deste projeto torna-se simples: além de ser uma ótima oportunidade de aprendizado para a equipe, tanto nos termos técnicos da plataforma quanto no gerenciamento de projetos, este trabalho tem como objetivo continuar o desenvolvimento da plataforma robótica, permitindo a realização de trabalhos cada vez mais elaborados.

\newpage
\section{Fundamentação Teórica}
\label{sec:secfundamentacaoteorica}
\subsection{Visão geral do sistema}
O sistema consiste de três camadas lógicas: Baixo Nível, Alto Nível e Supervisória. A camada de baixo nível é responsável pelo controle e realimentação do hardware instalado na plataforma robótica Bellator. Já a camada de alto nível é responsável por proporcionar um meio de comunicação entre a camada supervisória e a de Baixo Nível, além de gerar realimentação visual, através de stream de vídeo, para a camada supervisória. Finalmente, a camada supervisória deve providenciar ao usuário uma interface visual simples para o controle da plataforma robótica. A figura a seguir mostra esta configuração na forma de um diagrama em blocos.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{visaogeral.png}
  \end{center}
  \caption{Visão Geral do Sistema}
  \label{visaogeral}
\end{figure}

O robô Bellator é constituído das camadas de baixo nível e alto nível. A camada supervisória não faz parte do robô, apenas comunica-se com ele. Cada uma destas camadas será explicada em maiores detalhes nas seções seguintes.

\subsection{Camada Supervisória}
\subsubsection{Hardware}
A camada lógica supervisória, representada na figura \ref{visaogeral} não é componente do robô Bellator. Esta camada possui os seguintes elementos:

\begin{itemize}
  \item Uma Plataforma capaz de executar aplicativos Java, com suporte à vídeo e comunicação Wireless.
  \item Um Joystick, detalhado na seção \ref{sec:secjoystick}
\end{itemize}

A camada supervisória proporciona ao usuário final uma interface simples de controle da plataforma robótica. Como mencionado acima, é necessária uma plataforma capaz de executar aplicativos Java, visto que o software desenvolvido nesta camada foi escrito em Java e, além disso, é necessário que esta plataforma possua suporta à vídeo, pois o software proporciona realimentação visual para o usuário através de uma interface gráfica. Ainda, a plataforma deve possuir um meio de comunicação Wireless, visto que a camada de alto nível, apresentada na seção \ref{sec:secaltonivel}, necessita de uma conexão Wireless com a camada supervisória para o funcionamento do sistema. Os elementos desta camada estão representados no diagrama em blocos a seguir:

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{dsupervisorio.png}
  \end{center}
  \caption{Diagrama em Blocos da Camada Supervisória}
  \label{dsupervisorio}
\end{figure}

\subsubsection{Software}
O principal componente desta camada é o software Supervisor Remoto. Sua funcionalidade é a de interfaceamento do sistema como um todo com o usuário final. Disponibiliza ao usuário uma consulta aos dados coletados do robô, como imagens capturadas pela webcam e medições de distância realizadas pelos sensores infra-vermelhos. Também capacita o usuário a controlar o robô por meio de um joystick, o qual deve estar acoplado ao computador executando o software supervisor remoto.

Como o software foi desenvolvido em Java, este pode ser executado em plataformas Windows, Linux e Mac.

\subsection{Camada de Alto Nível}
\label{sec:secaltonivel}
\subsubsection{Hardware}
\label{sec:secaltonivelhardware}
A camada lógica de alto nível, representada na figura \ref{visaogeral} é componente do robô Bellator. Os elementos desta camada são:

\begin{itemize}
  \item PC Embarcado, detalhado na seção \ref{sec:secpcembarcado}
  \item Uma Webcam, detalhada na seção \ref{sec:secwebcam}
\end{itemize}

Esta camada é fundamental ao sistema, pois deve proporcionar um canal de comunicação entre a camada supervisória e a de baixo nível, bem como prover uma realimentação visual para a camada supervisória por meio de um stream de vídeo. Estas funções não poderiam ser realizadas apenas com os elementos da camada de baixo nível. Os elementos desta camada estão representados no diagrama em blocos a seguir.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{daltonivel.png}
  \end{center}
  \caption{Diagrama em Blocos da Camada de Alto Nível}
  \label{daltonivel}
\end{figure}

\subsubsection{Software}
O software desenvolvido para esta camada tem a função de fazer a comunicação entre as camadas de baixo nível e supervisória. Funciona basicamente como um roteador de mensagens entre estas duas camadas, encaminhando comandos de movimentação advindos da camada supervisória à camada de baixo nível e medições realizadas pelos sensores IR, bem como as imagens capturadas pela webcam, à camada supervisória.

\subsection{Camada de Baixo Nível}
\subsubsection{Hardware}
\label{sec:secbaixonivelhardware}
A camada lógica de baixo nível, representada na figura \ref{visaogeral}, faz parte do robô Bellator. Esta camada possui os seguintes elementos:

\begin{itemize}
  \item A placa C8051F340DK, detalhada na seção \ref{sec:secC8051F340DK}
  \item Seis sensores infra-vermelho detalhados na seção \ref{sec:secsensores}
  \item Uma placa para roteamento das leituras dos sensores e dos PWMs para a placa C8051F340DK, descrita em \ref{sec:secplacaderoteamento}
  \item Motores, rodas e outros elementos detalhados em \ref{sec:secrobobellator}
\end{itemize}

Esta camada deverá realizar a geração de PWMs para o controle dos motores do robô, bem como realizar a leitura dos sensores infra-vermelho. A geração do PWM deve ser controlada por meio de uma comunicação serial com a camada de alto nível. O diagrama em blocos a seguir representa esta camada e seus elementos.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{dbaixonivel.png}
  \end{center}
  \caption{Diagrama em Blocos da Camada de Baixo Nível}
  \label{dbaixonivel}
\end{figure}

\subsubsection{Software}
O software da camada de baixo nível executa na placa C8051F340DK e é responsável por controlar esta placa e suas funções na camada de baixo nível. A função deste software é geração de PWM para os dois motores do robô, a  varredura dos sensores de distância e envio das informações obtidas destes sensores para a camada de alto nível e, ainda, a interpretação e execução dos comandos recebidos da camada de alto nível.

\subsection{Protocolo de Comunicação}
\label{sec:protocolo}
O protocolo de comunicação, que foi utilizado por todas as camadas (supervisória, alto nível e baixo nível), consiste em uma especificação de comandos. Uma lista de todos os comandos do protocolo pode ser acessada no anexo A. Todas as mensagens passadas seguem o padrão:

\begin{center}
COMANDO VALOR FIM\_COMANDO
\end{center}

Onde COMANDO é um byte que representa qual é o comando, VALOR um conjunto de zero ou mais bytes para o valor do COMANDO (dependendo do comando) e FIM\_COMANDO é o byte 0xFE, que indica que o comando termina ali.

Dentre os comandos previstos no protocolo, os utilizados foram:
\begin{itemize}
    \item RODA\_LEFT (0xA0): Este comando serve para controlar o sentido de rotação e a largura de PWM do motor que controla a roda esquerda do robô. A mensagem passada segue o padrão:

\begin{center}
RODA\_LEFT VALOR FIM\_COMANDO
\end{center}

VALOR é composto por apenas 1 byte no caso deste comando, onde o bit mais significativo representa o sentido (1 para fazer a roda girar pra frente e 0 para o contrário), e os outros 7 bits correspondem a  um valor decimal entre 0 e 15 inclusive, para selecionar um dos 16 níveis de PWM. O valor 0 indicaria o motor parado, enquanto o valor 15 corresponde à velocidade máxima.
    \item RODA\_RIGHT (0xA1): Funcionamento idêntico ao comando anterior, só que para o controle do motor da roda direita (sentido de rotação e largura de PWM).
    \item STOP (0xFF): Comando para zerar a PWM dos dois motores, não tem nenhum byte de valor, utilizado da seguinte forma:
\begin{center}
STOP FIM\_COMANDO.
\end{center}
    \item SENSOR\_OPTICO\_0 (0x22): Comando utilizado para passar a leitura do sensor óptico 0, já convertida pelo conversor AD. A mensagem contém, então, 3 bytes:
\begin{center}
SENSOR\_OPTICO\_0 VALOR FIM\_COMANDO,
\end{center}
onde VALOR é o valor da conversão AD, composto por apenas 1 byte. A mesma estrutura é utilizada para os cinco comandos seguintes.
    \item SENSOR\_OPTICO\_1 (0x23): utilizado para o sensor 1.
    \item SENSOR\_OPTICO\_2 (0x24): utilizado para o sensor 2.
    \item SENSOR\_OPTICO\_3 (0x25): utilizado para o sensor 3.
    \item SENSOR\_OPTICO\_4 (0x26): utilizado para o sensor 4.
    \item SENSOR\_OPTICO\_5 (0x27): utilizado para o sensor 5.
\end{itemize}
Os demais comandos descritos no protocolo são para utilização em uma continuação do projeto.

\subsection{Bibliotecas Externas}
\label{sec:bibExternas}
O projeto inclui, basicamente, duas tarefas que não são nativamente executadas pela linguagem Java, a reprodução de vídeo e a interface com o joystick. Para realizá-las, a equipe procurou por bibliotecas em Java que fossem gratuitamente distribuídas e que realizassem estas tarefas.

Para a reprodução de vídeo, o player VLC \cite{videolan} disponibiliza uma biblioteca para desenvolvedores, a libVLC, distribuída sob a licença GNU General Public License v2 \cite{gpl2}.
Como esta biblioteca é escrita em linguagem C++, a equipe utilizou um wrapper para Java, o vlcj \cite{vlcj} que é distribuído sob a licença GNU General Public License v3 \cite{gpl3}. Este wrapper tem determinadas funções que permitem ao desenvolvedor tratar um stream, seja ele de áudio ou vídeo, com as funcionalidades implementadas na libVLC. Neste projeto foram utilizadas somente as funções de conexão de stream de vídeo, como abrir uma nova conexão, tocar, pausar e parar o vídeo. A interface de vídeo com o usuário pode ser feita utilizando tanto a Java AWT Window como o Swing JFrame.

O vlcj necessita da biblioteca JNA \cite{jna} para acessar a libVLC nativa do sistema onde o código esteja sendo executado. O JNA é distribuído sob a licença GNU Lesser General Public License v3 \cite{lgpl3}.

Para a interface com o joystick, foi utilizada a biblioteca JInput \cite{jinput} . A JInput é distribuida gratituitamente sob a licença BSD \cite{bsdlicense}. Esta tem como funcionalidade o reconhecimento e a captura dos comandos de interfaces de controle como teclado, mouse e joysticks, porém neste projeto foi utilizada somente esta última.
Para captura dos comandos, a biblioteca disponibiliza a técnica de pooling, sendo este retorno do controlador analógico dividido em dois valores: componente do eixo das abcissas e das ordenadas. Estes valores estão situados no intervalo de [-1;1], obtendo-se valores positivos com comandos acima do eixo de origem para o caso das ordenadas e a direita do mesmo para o eixo das abcissas.

\section{Projeto}
\subsection{Projeto do Software Supervisor Remoto}
\label{projSW}
O sistema supervisor remoto é um software desenvolvido em linguagem Java, o qual basicamente tem como objetivo interfacear o sistema Bellator com o usuário. O supervisor mostra a leitura dos sensores, juntamente com as imagens captadas pela webcam, para guiar o usuário no controle remoto do robô, o qual é realizado através do joystick.

A escolha da linguagem utilizada no desenvolvimento do software foi baseada em alguns requisitos específicos. Um destes foi o suporte para tratamento de stream de vídeo, para que fosse possível a agregação do mesmo à interface do software. Outro foi o de suporte para captura de comandos de um joystick, para que o usuário possa utilizá-lo para controlar a movimentação do robô. A linguagem escolhida deve também ter capacidade de tratamento de sockets, com o fim de concretizar a comunicação wireless de troca de dados com o sistema (tais como enviar comandos do joystick e receber dados dos sensores). Como Java atende a todos estes requisitos, se tornou a opção mais viável para o desevolvimento do sistema supervisor remoto.

Para desenvolver esta etapa fundamental foi realizado um projeto do software, o qual é composto por um levantamento de requisitos, casos de uso, e um diagrama de classes. Estes serão abordados nas seções seguintes.

\subsubsection{Levantamento de Requisitos}
Para iniciar o desenvolvimento de um software é necessário primeiramente saber o que o software deve ser capaz de fazer, quais suas funcionalidades e restrições. Portanto foi desenvolvido um levantamento de requisitos para o sistema supervisor remoto.

\textbf{Requisitos Funcionais:}
\begin{itemize} % Cria uma lista
  \item O software deverá mostrar a imagem capturada pela webcam na tela para o usuário.
  \item O software deverá mostrar os dados dos sensores (adquiridos via interface serial) na tela para o usuário.
  \item O software deverá possibilitar ao usuário controlar a movimentação do robô remotamente através de um joystick.
% Esta abaixo: reescrevi isso já vejam se tá bom
  \item O software deverá possibilitar ao usuário a configuração da conexão de dados com o robô para envio comandos do joystick e recebimento de dados capturados pelos sensores.
  \item O software deverá possibilitar ao usuário a configuração da conexão do stream de vídeo.
% E esta abaixo estão com pontos de interrogação, precisa melhorar.reescrevi já
  \item O software deverá possibilitar ao usuário o acesso através da interface gráfica ao manual do usuário.
\end{itemize}

\textbf{Requisitos Não-Funcionais:}
\begin{itemize} % Cria uma lista
  \item O software poderá ser executado em plataformas Windows, Linux e Mac.
  \item O delay do stream de vídeo não deverá ultrapassar os 1500ms.
  \item O software deverá ser desenvolvido em Java, utilizando o paradigma orientado a objetos.
\end{itemize}

\subsubsection{Estudo de Casos de Uso}
Feito o levantamento de requisitos, o próximo passo do projeto do software supervisor remoto foi o estudo dos casos de uso do mesmo, o qual foi baseado nos requisitos levantados do sistema. Este estudo mostrou que o software supervisor remoto é composto por seis principais casos de uso mostrados na figura \ref{casouso} .
\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{dcasouso2.jpg}
  \end{center}
  \caption[Diagrama de Casos de Uso.]
  {Diagrama de Casos de Uso.}
  \label{casouso}
\end{figure}
% Tem umas coisas pra arrumar nessa figura, cats fale comigo depois já arrumei algumas coisas. O novo diagrama tá lá no dropbox

Para que o usuário possa interagir com o robô, primeiramente é necessário que o usuário conecte o sistema supervisor remoto ao robô. Para isso é necessário que exista uma conexão de rede entre o PC embarcado e o PC supervisor remoto. Tendo isto, é necessário fornecer o IP e a porta da conexão do socket de dados, respeitando o formato (IP:Porta), para que os dados dos sensores possam ser mostrados na tela para o usuário. Também é necessário fornecer ao sistema a URL do stream de vídeo, a qual tem o formato (http://IP:Porta/robo.mjpeg), para que o usuário possa ter à disposição as imagens capturadas pela webcam do robô. Caso não exista conexão de rede entre o PC embarcado e o supervisor remoto, a interação com o robô torna-se indisponível.

Com estas configurações, o usuário pode visualizar os dados dos sensores e o vídeo capturado pela câmera, porém ainda não é possível o controle remoto do mesmo. Para isto, além de todos os requisitos anteriormente citados, é preciso ter um joystick conectado ao PC supervisor remoto, para que o usuário possa utilizá-lo no controle de movimentação do robô. Caso o sistema não encontre um joystick, o usuário é informado pela própria interface e o controle do robô fica indisponível.

\subsubsection{Diagrama de Classes}
Para guiar o desenvolvimento do software, foi construído um diagrama de classes inicial seguindo o padrão UML \cite{uml}, sendo este editado e atualizado ao longo da fase implementação. O diagrama de classes final do sistema pode ser observado na figura \ref{dclasse}. Nota-se que foram previstas seis classes principais para o sistema, sendo a ControlePrincipal responsável por gerenciar todos os componentes utilizados no sistema (comunicação de dados, protocolo de comunicação, stream de Vídeo, controle do robô via Joypad e interface com o usuário), e as demais responsáveis por um componente cada.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{dclasse.jpg}
  \end{center}
  \caption [Diagrama de Classes.]
  {Diagrama de Classes.}
  \label{dclasse}
\end{figure}

Os detalhes de implementação do software serão abordados de maneira aprofundada na seção \ref{supervisorRemoto}.

\subsection{Projeto do Hardware}

\subsubsection{C8051F340DK}
\label{sec:secC8051F340DK}
O C8051F340 é uma unidade micro controladora (MCU) equipada com um processador  da família 8051 e vários dispositivos periféricos dispostos em uma placa de circuito impresso. Esta unidade faz parte do robô Bellator e possui as seguintes especificações \cite{datasheetkit}:

\begin{itemize} % Cria uma lista
  \item Conversor ADC 10 bits de até 200ksps (amostras por segundo)
  \item Dois comparadores
  \item Brown-out Reset e Power-on Reset
  \item Tensão de Referência interna
  \item Porta USB 2.0
  \item Duas interfaces seriais (UART) e uma interface SPI
  \item Fonte de Alimentação de 2.7 até 5.25V regulada internamente
  \item Micro-processador 8051 de até 48 MIPS
  \item 4352 Bytes de memória RAM
  \item 40 Portas I/O
  \item 4 Timers de 16 bits
  \item Seleção de Clock interno de alta ou baixa velocidade ou clock externo
\end{itemize}

Um diagrama em blocos do kit, retirado do datasheet, pode ser visto abaixo:

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{dbloc.png}        
  \end{center}
  \caption[Diagrama em blocos do kit C8051F340DK.]
  {Diagrama em blocos do kit C8051F340DK. Fonte: datasheet.}
  \label{dbloc}
\end{figure}


\subsubsection{Sensor IR 2Y0A02F98}
\label{sec:secsensores}
Com o objetivo de auxiliar a navegação do robô e fazer varreduras do ambiente, foram instalados seis sensores analógicos de distância por infravermelho modelo 2Y0A02F98 da Sharp, dispostos uniformemente nas laterais da plataforma Bellator. Este modelo mede distâncias no intervalo de 20 a 150 centímetros \cite{datasheetsensor}, sendo que os valores de tensão de resposta do sensor seguem a curva mostrada na figura \ref{curva} .

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{curvaresp.png}
  \end{center}
  \caption[Curva de resposta do sensor de distância.]
  {Curva de resposta do sensor de distância. Fonte: datasheet.}
  \label{curva}
\end{figure}

Pode-se observar que o modelo é pouco influenciado pelas cores dos objetos refletidos, isto devido ao método de medição baseado em triangulação \cite{datasheetsensor}. O sensor possui uma tensão de alimentação recomendada na faixa de 4.5 a 5.5V, a qual não é atendida pela plataforma utilizada \cite{datasheetkit}, sendo necessária utilização de alimentação especial. Esta alimentação é realizada através de um circuito regulador de tensão, o qual utiliza alimentação da própria bateria acoplada ao robô. O cálculo dos valores dos resistores foram baseados na equação \ref{eqRegulador}.
\begin{equation}
\label{eqRegulador}
V_{OUT} = 1,25V (1 + R_{2}/R_{1})
\end{equation}
O diagrama esquemático do regulador de tensão é mostrado na figura \ref{regulador}.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{regulador.jpg}
  \end{center}
  \caption[Diagrama esquemático do regulador de tensão dos sensores de distância.]
  {Diagrama esquemático do regulador de tensão dos sensores de distância.}
  \label{regulador}
\end{figure}

As respectivas dimensões do sensor IR, em milímetros, são mostradas na figura \ref{dimsens}

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{dimsens.png}        
  \end{center}
  \caption[Dimensões do sensor GP2Y0A02F98YK.]
  {Dimensões do sensor GP2Y0A02F98YK. Fonte: datasheet.}
  \label{dimsens}
\end{figure}

Para agregar os sensores à plataforma, primeiramente foi levantada a curva de resposta dos mesmos. Com estes dados, foi feita uma aproximação polinomial da curva de resposta e, com a equação resultante \ref{eq_sensores}, foram calculados 256 pontos entre o intervalo de operação. Esta tabela resultante, de formato tensão(V) X distância(cm), foi armazenada no nível supervisor remoto para ser utilizada para obtenção das respostas dos sensores (distância em centímetros).

\begin{equation}
\label{eq_sensores}
V_{medido} = 2,01091E-8x^4-8,7740E-6x^3+0,0014x^2-0,1152x+4,3134
\end{equation}

O modelo em questão é adequado ao projeto pois, como sua principal finalidade é a de ajudar a navegação do robô em ambientes fechados, sua faixa de resposta de 20 a 150 centímetros é suficiente para detecção de objetos. Contudo, há a possibilidade de num projeto futuro serem acrescentados outros tipos de sensores mais precisos voltados à medição de distâncias menores.

\subsubsection{Placa de Roteamento}
\label{sec:secplacaderoteamento}
A placa de roteamento foi desenvolvida pela equipe visando proporcionar a alimentação de 5 Volts necessária para os sensores infra-vermelho, descritos na seção \ref{sec:secsensores}, rotear cada leitura dos sensores para o PORT2 da C8051F340DK e fazer um buffer para os sinais de PWM gerados pela C8051F340DK.

A figura a seguir é um diagrama do circuito da placa de roteamento.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{dplaca.png}
  \end{center}
  \caption{Diagrama da Placa de Roteamento}
  \label{dplaca}
\end{figure}


\subsubsection{Webcam}
\label{sec:secwebcam}
O modelo da webcam utilizada no robô Bellator é Genius iLook 316, que possui as seguintes especificações :
\begin{itemize}
  \item[-] Resolução: VGA 640x480 pixels.
  \item[-] Taxa máxima de frames por segundo: 15, na resolução utilizada.
\end{itemize}

Mais especificações sobre a série iLook 300 da Genius podem ser encontradas no site oficial da empresa, incluso nas referências bibliográficas. \cite{webcam}

A escolha do modelo de webcam já tinha sido realizada, sendo que a mesma atende os requisitos do projeto.

\subsubsection{Robô Bellator}
\label{sec:secrobobellator}
O robô Bellator possui duas rodas de tração e uma roda de apoio. As rodas de tração estão nas laterais da parte traseira do robô e possuem diâmetro de 20 centímetros e espessura de aproximadamente 4 centímetros. Ambas possuem um encoder de quadratura acoplado, o qual tem resolução de 1800 pulsos por volta. A roda de apoio está no centro da parte dianteira do robô e possui diâmetro de aproximadamente 6 centímetros e espessura de 2 centímetros. Todas as rodas são da marca Schioppa. Os outros componentes do robô estão listados a seguir:
\begin{itemize}
  \item[-] 2 Motores Bosch FPG 12V
  \item[-] Bateria Unybatt 12V-7.2 Ampére-hora
  \item[-] Duas pontes H L 298
\end{itemize}

Uma imagem do robô, parcialmente montado, pode ser visualizada a seguir:

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{roboBellator.jpg}        
  \end{center}
  \caption[Foto do robô Bellator]
  {Foto do robô Bellator.}
  \label{fotorobo}
\end{figure}

\subsubsection{PC embarcado}
\label{sec:secpcembarcado}
O PC embarcado é uma VIA EPIA M-Series Mini-ITX Mainboard, uma plataforma 32bits ultra compacta projetada especialmente para aplicações digitais embarcadas. A placa possui as dimensões de 17 por 17 centímetros e vários dispositivos integrados. Alguns deles estão listados a seguir:
\begin{itemize}
\item[-] Processador VIA C3/Eden EBGA
\item[-] Slot DDR226DIMM
\item[-] Duas portas IDE ATA /133/100
\item[-] Um slot PCI
\item[-] Duas portas USB 2.0
\item[-] Uma porta ethernet 10/100
\end{itemize}

Uma imagem descritiva com os principais elementos do PC embarcado, retirada do datasheet da mesma \cite{datasheetpclinux}, pode ser visualizada a seguir:

\begin{figure}[H]
\begin{center}
\includegraphics[width=\textwidth]{pcembarcado.png}
\end{center}
\caption[VIA EPIA M-Series Mini\-ITX Mainboard]
{VIA EPIA M-Series Mini\-ITX Mainboard. Fonte: Datasheet.}
\label{pcembarcado}
\end{figure}

Além do que está representado na \ref{pcembarcado}, o PC embarcado está equipado com uma memória RAM PC133 de 128mb e uma placa de rede Wireless Edimax PCI-LAN EW-7128G \cite{datasheetwireless} .

\subsubsection{Interconexão do Hardware}
\label{sec:secinterconexaodohardware}
Os elementos de hardware descritos até agora devem ser conectados de forma correta para o funcionamento da plataforma robótica Bellator. Esta seção visa descrever como estas conexões devem ser feitas.
Cabe aqui lembrar que, como descrito nas seções \ref{sec:secaltonivelhardware} e \ref{sec:secbaixonivelhardware} o robô Bellator é composto por todos os elementos da camada de baixo e alto nível, ou seja:

\begin{itemize}
  \item A placa C8051F340DK, detalhada na seção \ref{sec:secC8051F340DK}
  \item Seis sensores infra-vermelho detalhados em \ref{sec:secsensores}
  \item Uma placa para roteamento das leituras dos sensores e dos PWMs para a placa C8051F340DK
  \item Motores, rodas e outros elementos detalhados em \ref{sec:secrobobellator}
  \item PC Embarcado, detalhado na seção \ref{sec:secpcembarcado}
  \item Uma Webcam, detalhada na seção \ref{sec:secwebcam}
\end{itemize}

As figuras a seguir, explicadas nos parágrafos seguintes, servem como instrução para o posicionamento destes elementos:

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{figposicionamento.png}
  \end{center}
  \caption{Posicionamento dos Elementos do Robô - Parte 1}
  \label{figposicionamento}
\end{figure}

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{figposicionamento2.png}
  \end{center}
  \caption{Posicionamento dos Elementos do Robô - Parte 2}
  \label{figposicionamento2}
\end{figure}

Na figura \ref{figposicionamento}, que é uma foto editada do robô, antes da montagem final do mesmo, os números correspondem aos seguintes elementos:

\begin{enumerate}
  \item Nesta plataforma elevada deverá ser colocado o PC embarcado. Abaixo desta plataforma encontram-se os motores e um espaço (em baixo relevo na superfície do robô) onde a bateria deve ser posicionada.
  \item Nesta plataforma, na parte posterior do robô, devem ser colocados a placa C8051F340DK e, logo abaixo, a placa de roteamento.
  \item Posição do Sensor 1
  \item Posição do Sensor 2
  \item Posição do Sensor 3
\end{enumerate}

Os sensores 1 e 3 devem estar inclinados de 45º em sentidos opostos de forma a apontar, respectivamente, para o noroeste e nordeste do robô, onde o norte do robô é o número 4 na figura \ref{figposicionamento}. A Webcam deverá ser posicionada acima do PC embarcado e conectada neste via USB.

Na figura \ref{figposicionamento2}, retirada durante a montagem do robô, os números correspondem aos seguintes elementos:

\begin{enumerate}
  \item Posição do Sensor 4
  \item Posição do Sensor 5
  \item Posição do Sensor 6
\end{enumerate}

Os sensores e os sinais de PWM devem ser conectados à placa de roteamento de acordo com o diagrama da placa de roteamento, apresentado na seção \ref{sec:secplacaderoteamento}. De acordo com a figura \ref{dplaca}, cada sensor deve ser conectado da seguinte forma: Sensor 1 em S0, Sensor 2 em S1, até Sensor 6 em S5. Nota-se que o número 1 representa a alimentação de 5V do sensor, que corresponde ao cabo vermelho do conector deste. Os conectores DCI devem ligar o PORT1 da placa de roteamento ao PORT1 da placa C8051F340DK e, analogamente, o PORT2 da placa de roteamento ao PORT2 da C8051F340DK. Os sinais de PWM 1 e 2 devem ser conectados à ponte H da direita do robô e os sinais 3 e 4 na da esquerda, a partir da perspectiva vista na figura \ref{figposicionamento2}.

Além disso, a porta serial da placa C8051F340DK deve ser conectada ao pc embarcado e, finalmente, a alimentação da placa de roteamento, da C8051F340DK, das pontes H, motores e da fonte do pc embarcado devem ser conectadas nos pólos da bateria.

\subsubsection{Joystick}
\label{sec:secjoystick}
O joystick utilizado no projeto é um controle de Sony Playstation 2. Primeiramente a escolha por utilizar um joystick foi devido a geração de sinal analógico de saída, o que o torna interessante para controle da velocidade de movimentação do robô.  Dentre as opções de controladores analógicos, esta escolha foi feita devido à maior precisão do sinal analógico gerado pelo controle em questão, ou seja, este possui uma maior resolução. Outro ponto forte é a presença de dois controladores analógicos, sendo um voltado ao movimento do robô e o outro para possível controle da câmera num projeto futuro.

A conexão deste controlador é padrão da Sony PS2, sendo portanto utilizado um adaptador deste padrão para USB, com o intuito de conectá-lo ao computador. Uma imagem do joystick, juntamente com seu adaptador para USB, pode ser visualizada na figura \ref{joystick}.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{joystick.png}        
  \end{center}
  \caption[Joystick de Sony Playstation 2.]
  {Joystick de Sony Playstation 2. Fonte <http://www.easytechnology.gr/images/PS2\_sony\_ps2\_controller.jpg>}
  \label{joystick}
\end{figure}

Agregando este controlador à biblioteca JInput (veja \ref{sec:bibExternas}), os valores retornados pela mesma quando aplicado um comando em cada eixo pertencem ao intervalo [-1;1], sendo o valor positivo para cima da origem no eixo das ordenadas e para esquerda no eixo das abcissas.

Os comandos de movimento do robô são realizados utilizando o controle analógico direito do joystick. Se o comando possuir uma componente no eixo Y este se move proporcionalmente a essa componente em módulo e com mesmo sentido. Se contiver componente no eixo X o movimento é de rotação (sentido horário para componente positiva, caso contrário sentido anti-horário).

\newpage
\section{Execução}
\subsection{Estado do Sistema}
\label{sec:estadoSistema}
Como já mencionado anteriormente, este projeto é a continuação de trabalho que vem sendo desenvolvido no robô Bellator, e no qual várias outras pessoas já trabalharam. Assim, convém descrever quais eram as características do robô quando o projeto foi iniciado pela equipe. Na camada de alto nível, o robô possuía um PC Linux, que não foi alterado pela equipe, e na camada de baixo nível possuía uma placa com processador AT89C52 em uma placa P51, com um código funcional, ao qual a equipe teve acesso.

A equipe analisou o andamento do projeto entregue através de discussão com o responsável anterior e pela análise dos programas já existentes, e a partir disto, concluiu que o mesmo possuía as seguintes características:
\begin{itemize}
  \item[-] Geração de PWM a partir do AT89C52 para acionamento dos motores, controlável com comandos enviados através da porta serial.
  \item[-] Recepção da imagem da Webcam pelo PC Linux, roteamento e acesso do stream por uma conexão Wireless funcional.
  \item[-] Todas estas funcionalidades foram testadas em módulos separados apenas, e não como um todo.
  \item[-] Um protocolo de comunicação, que definia os vários comandos possíveis.
  \item[-] Não havia, ainda, leitura de nenhum sensor infravermelho.
\end{itemize}

O software executando no PC Linux embarcado, como mencionado, não foi alterado e já fazia as operações necessárias para o sistema, descritas na seção visão geral do sistema. Também foi entregue um software, ainda no início do seu desenvolvimento, que capturava comandos do joystick. A visualização do stream de vídeo da webcam era realizada através do VLC player \cite{videolan}. Este software não foi utilizado pela equipe, a mesma optou por implementar um novo programa em Java, como mencionado na seção \ref{projSW}, visando um programa mais versátil e independente de plataforma.

\subsection{Software Supervisor Remoto}
\label{supervisorRemoto}
O software supervisor remoto, como citado anteriormente, é responsável pelo gerenciamento do sistema como um todo e da interface com o usuário. A interface do programa pode ser observada na figura \ref{supervisor_remoto}.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{supervisor_remoto.jpg}
  \end{center}
  \caption [Interface do software Supervisor Remoto.]
  {Interface do software Supervisor Remoto.}
  \label{supervisor_remoto}
\end{figure}

Este pode ser dividido em basicamente cinco módulos: Util, Principal, Controlador, Comunicação e Interface Gráfica, os quais serão detalhados nas seções a seguir.

%Melhorar as explicações de todos os módulos, referenciar o protocolo %adequadamente

\subsubsection{Util}
O núcleo Util consiste basicamente em dados a serem consultados pelo software durante sua execução, dados que correspondem ao protocolo (ver \ref{sec:protocolo}) de comunicação utilizado na troca de mensagens entre o controle embarcado (alto nível) e o supervisor, e a tabela de respostas dos sensores IR acoplados ao robô. Toda mensagem entre as camadas de alto nível e supervisória consiste em um vetor de bytes e deve respeitar este protocolo, que determina a formatação da mesma para envio/recebimento.

\subsubsection{Principal}
% Nota: do “Este” pra baixo: confuso.
O módulo Principal é responsável pela coordenação da execução do software, ou seja, é este núcleo que faz a agregação de todos os módulos para formar um só sistema. A execução do software inicia com a chamada do método executar da classe ControlePrincipal. Este módulo consiste na thread que executa o laço principal do programa, o qual é responsável pela leitura, decodificação das mensagens recebidas pelo módulo de Comunicação (ver ref{sec:comunicacao}); atualização dos dados na interface gráfica e; encaminhamento dos comandos do joystick, capturados através do módulo Controlador (ver \ref{sec:controlador}), para a camada de alto nível utilizando novamente o núcleo de Comunicação do software. O diagrama da figura \ref{dcontrolePrincipal} ilustra o funcionamento deste módulo.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{controlePrincipal.png}
  \end{center}
  \caption [Funcionamento do módulo Controle Principal.]
  {Funcionamento do módulo Controle Principal.}
  \label{dcontrolePrincipal}
\end{figure}

% Explicar o joystick em outro lugar Cats: Acho que a lógica do tratamento das mensagens do %controle devem ficar aqui. Só tirei a parte que falava do retorno pertencer a [-1;1]
Para envio dos comandos realizados pelo usuário, primeiramente o software captura valores do joystick através de polling e os converte em valores inteiros no intervalo [0, 15] que são interpretados pelo robô. Feita a transformação, é necessária uma lógica de controle do robô através do joystick, já que para movimentação do robô é preciso mandar uma mensagem para cada roda. Esta lógica é bem simples e é detalhada a seguir:
\begin{itemize}

\item Se o comando só possui componente no eixo Y, as duas rodas recebem uma força proporcional à aplicada ao joystick;

\item Se o comando, além de possuir componente no eixo Y, também possuir no eixo X, uma das rodas tem sua força diminuída de acordo com o sentido da componente em X, enquanto a outra mantém sua força aplicada;

\item Se o comando somente possuir  componente no eixo X, é aplicada em ambas as rodas metade da força total, porém em sentidos opostos para realizar o movimento de rotação.
\end{itemize}

A codificação destas mensagens para envio, é baseada no protocolo (ver \ref{sec:protocolo}) e feita da seguinte maneira:
\begin{itemize}

\item mensagem[byte 0]: Indicador para qual roda é destinada a mensagem (RODA\_RIGHT ou RODA\_LEFT);

\item mensagem[byte 1]: Força da roda (0 a 15). Se o movimento da roda é no sentido oposto soma-se MASCARA\_SENTIDO ao byte;

\item mensage[byte 2]: FIM\_COMANDO;

\item mensagem[byte 3]: Indicador de nova linha (\textbackslash n);
\end{itemize}

A decodificação das mensagens recebidas, sendo no caso dados dos sensores acoplados ao robô, é baseada no protocolo e feita da seguinte forma:
\begin{itemize}

\item Faz a seleção baseada no protocolo de qual sensor atualizar através do byte 0 da mensagem;

\item Consulta a tabela dos sensores através do byte 1 da mensagem para aquisição da distância medida;

\item Atualiza o campo do respectivo sensor na interface gráfica com o valor medido;
\end{itemize}

\subsubsection{Controlador}
\label{sec:controlador}
O módulo do Controlador corresponde à interface com o joystick usado para controlar o robô. É este módulo que a Principal utiliza para os métodos de verificação da existência de um joystick no sistema e captura de seus comandos feitos pelo usuário, sendo este último realizado por pooling. A grande maioria dos métodos implementados neste módulo são baseados no uso da biblioteca JInput, citada na seção \ref{sec:bibExternas}.

\subsubsection{Comunicação}
\label{sec:comunicacao}
O módulo de Comunicação consiste no controle da conexão por socket do supervisor remoto com o sistema de alto nível, sendo assim responsável pelo envio de comandos do joystick e recebimento de medidas dos sensores. Primeiramente esse tenta estabelecer uma conexão com o PC embarcado, sendo que se obtiver sucesso inicializa uma thread que faz o papel de ouvinte de mensagens vindas da camada de alto nível e envia eventuais comandos do joystick pela conexão. O diagrama mostrado na figura \ref{dComunicacao} mostra o funcionamento deste módulo.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{ouvinteMensagens.png}
  \end{center}
  \caption [Funcionamento do módulo Comunicação.]
  {Funcionamento do módulo Comunicação.}
  \label{dComunicacao}
\end{figure}

\subsubsection{Interface Gráfica}
O módulo da Interface Gráfica nada mais é do que a interface gráfica do software para a visualização dos dados pelo usuário. Essa consiste numa thread que é responsável por capturar e executar as instruções feitas pelo usuário, tais como configuração do stream de vídeo e socket de dados dos sensores, sair do programa, acessar o manual do usuário e controlar a execução do vídeo. Este módulo também é responsável pela visualização do stream de vídeo, o que é feito com a biblioteca vlcj, mencionada na seção \ref{sec:bibExternas}. A figura \ref{supervisorRemoto2} mostra a interface em funcionamento.

\begin{figure}[H]
  \begin{center}
      \includegraphics[width=\textwidth]{supervisorRemoto2.jpg}
  \end{center}
  \caption [Interface do software Supervisor Remoto em funcionamento.]
  {Interface do software Supervisor Remoto em fucionamento.}
  \label{supervisorRemoto2}
\end{figure}

Para maiores detalhes sobre a implementação, consultar javadoc do software (disponível em (...)Bellator -> doc -> index.html). Para detalhes sobre a utilização do software, consultar o documento Manual do Usuário, o qual pode ser consultado no menu Ajuda -> Manual do Usuário através do próprio software.

\subsection{Software de Baixo Nível}
\subsubsection{Migração para C8051F340DK}
O primeiro passo planejado para o projeto, após a análise do estado do código em C para a placa 8051, foi realizar a migração do código para a nova plataforma de desenvolvimento, o C8051F340DK. Inicialmente, este processo parecia simples, porém a nova plataforma possui várias características que dificultaram a migração. Os principais problemas encontrados durante a migração foram:

\begin{itemize}
  \item[-] O clock diferente da nova plataforma, o que invalidou todas as configurações dos temporizadores, que são baseados no clock da placa e controlam os outros dispositivos da placa.
  \item[-] A mudança da nomenclatura para o acesso de diversos registradores.
  \item[-] Falta de familiaridade da equipe com a nova plataforma.
\end{itemize}


O processo de migração iniciou-se com a transferência do código C existente para a nova plataforma de desenvolvimento. Obviamente, devido aos problemas acima descritos, o código necessitava de vários ajustes. A primeira parte reconfigurada foi a comunicação serial, essencial para realização de testes. Para isto, os valores para a geração do Baud Rate foram recalculados, para adequação ao novo clock, e alguns registradores modificados, já que a nova placa tem duas interfaces seriais disponíveis (UART0 e UART1), o que implica em mais registradores, com nomes diferentes. Apenas a UART0 foi utilizada.

Após o funcionamento da comunicação por porta serial, a seção do código que interpreta os comandos recebidos da camada de alto nível foi adaptada para utilizar o protocolo de comunicação.

Em seguida, o conversor AD foi configurado para realizar a varredura dos sensores de distância IR, conectados ao port 2 da placa C8051F340DK. Em posse dos dados de conversão, foi implementado o envio destas informações à camada de alto nível, onde as mensagens seguem a estrutura do protocolo, descrito na seção \ref{sec:protocolo}.

%Idem
Finalmente, foi reconfigurada a geração de PWM para os motores do robô.

Em todas as etapas citadas foram realizados testes, para conferir se a reconfiguração de uma função não havia afetado o funcionamento de outras.

\subsubsection{Funcionamento do Software}
%Talvez seja bom fundir essa seção com a de cima, ela já vai ter que ser mudada pra % inserir as figuras.
Inicialmente, o software de baixo nível realiza as configurações da comunicação serial, do conversor analógico/digital e da geração de PWM.

A configuração da comunicação serial é feita com o Timer1, responsável por gerar um baud rate de 115200 bps, foi configurada ainda para utilizar 8 bits e não utilizar bit de paridade.

O funcionamento do software pode ser dividido em três partes principais:

\begin{itemize}
  \item[-]Geração de PWM.
  \item[-]Varredura dos sensores de distância.
  \item[-]Interpretação de comandos recebidos do software supervisor.
\end{itemize}

A geração de PWM tem 4 saídas:
\begin{itemize}
  \item[-]Pino P1.1: contém a PWM responsável por fazer a roda direita girar para frente.
  \item[-]Pino P1.3: contém a PWM responsável por fazer a roda direita girar para trás.
  \item[-]Pino P1.5: contém a PWM responsável por fazer a roda esquerda girar para frente.
  \item[-]Pino P1.7: contém a PWM responsável por fazer a roda esquerda girar para trás.
\end{itemize}

A frequência dos sinais de PWM gerados é de 200Hz, logo o período é de 5ms. A geração de PWM é controlada na interrupção do Timer0. Existem duas variáveis para controlar a geração de PWM para cada motor, uma delas controla a largura (por quanto tempo dos 5ms do período o sinal de PWM estará ativo, um valor inteiro de 0 a 15 inclusive) e a outra controla o sentido (bit 0 ou 1, que representa para qual pino o sinal de PWM será enviado).

A varredura dos sensores de distância é controlada pelo Timer3 e funciona da seguinte forma: a cada 50ms, é disparada uma varredura, onde cada sensor tem seu valor de tensão (analógico), que está na faixa de 0 a 2.6V, convertido para um valor digital entre 0 e 255, através do uso do conversor AD da placa C8051F340DK. Os sensores estão conectados da seguinte forma na port 2 da placa:

\begin{itemize}
  \item[-]Sensor 1: pino P2.0;
  \item[-]Sensor 2: pino P2.1;
  \item[-]Sensor 3: pino P2.2;
  \item[-]Sensor 4: pino P2.3;
  \item[-]Sensor 5: pino P2.5;
  \item[-]Sensor 6: pino P2.6.
\end{itemize}

Após a conversão A/D da leitura de cada sensor, o valor convertido é armazenado em um vetor; em seguida, a próxima leitura a ser convertida é configurada para o pino do próximo sensor, a não ser que tenha ocorrido a conversão da leitura do sensor 6. Quando acaba a varredura (para os seis sensores de distância instalados na placa), uma flag que indica a disponibilidade de novas conversões tem seu valor alterado para verdadeiro. Posteriormente, o laço principal verificará essa flag, e então os valores convertidos serão enviados através da interface serial, utilizando o protocolo, como explicado na seção \ref{sec:protocolo}.

A interpretação de comandos recebidos funciona como segue: continuamente, a interface serial está sendo monitorada através da interrupção serial, em busca de mensagens no formato especificado na seção \ref{sec:protocolo}. Quando um fim de comando é recebido na interrupção, a flag que representa a detecção de um novo comando é acionada. No laço principal do programa, quando esta flag é avaliada como verdadeira, ocorre a interpretação do comando. No código atual, os seguintes comandos são interpretados:

\begin{itemize}
  \item[-]RODA\_LEFT.
  \item[-]RODA\_RIGHT.
  \item[-]STOP.
\end{itemize}

Para maiores informações sobre estes comandos, rever a seção do protocolo: \ref{sec:protocolo}.


\newpage
\section{Considerações Finais}

\subsection{Resultados}
Após a execução do projeto, a equipe obteve os seguintes resultados:

\begin{itemize}
  \item A geração de PWMs e leitura dos sensores pela C8051F340DK funciona.
  \item Apenas 1 dos 6 sensores de distância infra-vermelho instalados no robô apresentou defeito.
  \item A placa de roteamento funciona.
  \item Os motores funcionam de acordo com os PWMs gerados pela C8051F340DK.
  \item O PC embarcado realiza corretamente o roteamento das mensagens entre a camada supervisória e a camada de baixo nível, e, também, produz o stream de vídeo da webcam.
  \item O software Supervisor Remoto comunica-se corretamente com o PC embarcado e atende aos requisitos funcionais e não funcionais.
\end{itemize}

Além disso, após a montagem do robô, a equipe realizou testes do sistema como um todo, ou seja, do funcionamento de todas as camadas apropriadamente, assim como descritas na seção \ref{sec:secfundamentacaoteorica}. A equipe chegou a conclusão que o sistema funciona, porém, não de forma autônoma. Como mencionado na seção \ref{sec:sectrabalhosfuturos}, a bateria do robô Bellator não foi capaz de alimentar todos os componentes plataforma robótica. A partir dos testes, porém, a equipe concluiu que todo o sistema deve funcionar de forma autônoma, se corrigido este problema.

\subsection{Conclusão}
A realização deste projeto provou ser uma valiosa fonte de aprendizado para a equipe, tanto no âmbito de gerência de projetos quanto no de desenvolvimento, devido à variedade de conhecimentos agregados no mesmo. A proporção do projeto, a importância crítica do fator de integração de todos os módulos do projeto, o fato de o mesmo já estar em andamento e já possuir código implementado com pouca ou nenhuma documentação foram fatores essenciais para torná-lo desafiador para a equipe. A maior dificuldade da equipe ao desenvolver o projeto foi a falta de documentação do que já havia sido realizado previamente. Desta forma, para que as próximas equipes não passem pelas mesmas dificuldades, a presente equipe voltou boa parcela de seus esforços para o desenvolvimento de uma documentação detalhada sobre o projeto.

\subsection{Trabalhos Futuros}
\label{sec:sectrabalhosfuturos}
O robô Bellator é um sistema complexo, que possui diversos componentes cujo desempenho pode ser aprimorado, além de alguns problemas críticos a serem resolvidos. Na montagem realizada nesse projeto, nem todos os componentes previamente disponíveis na plataforma foram utilizados, como os encoders ou o sonar, e portanto existem diversas possibilidades para trabalhos futuros. Algumas sugestões para tais trabalhos serão listadas a seguir:

\begin{itemize}
  \item[-]Realimentação dos encoders. O robô possui dois encoders cujas informações não são utilizadas. Essa informação é útil para realimentar a lógica de movimentação do robô, e compensar o movimento das rodas quando necessário.
  \item[-]Sonar e servomovor. O robô possui também um sonar montado em uma base com um servomotor para realizar varreduras. Estes componentes podem ser integrados ao resto do sistema, permitindo ao usuário que controle a varredura remotamente através do joystick.
  \item[-]Alimentação do robô. O robô é alimentado por uma única bateria de 12 Volts, o que gera dois problemas. Primeiro, o consumo de todos os componentes do robô, somados, é demasiado alto, o que limita muito a sua autonomia. Segundo, a parte lógica e a parte de potência do robô possuem todas a mesma alimentação, e um pico de corrente ocasionado pelos motores facilmente derruba a fonte de alimentação do pc embarcado, e poderia inclusive danificar os componentes. Essas duas partes precisam ser devidamente separadas e ter alimentação própria, além de se comunicar exclusivamente através de optoacopladores.
  \item[-]Comunicação Wireless. Toda a comunicação do robô com a camada supervisória é feita via Wireless. Embora conveniente até o momento, esta tecnologia apresenta algumas limitações, principalmente em relação a alcance e consumo, e tendo como maior vantagem a taxa de transmissão de dados. Uma taxa alta é necessária para a transmissão de vídeo, mas uma solução mais adequada pode ser pesquisada.
\end{itemize}

\newpage
\clearpage
\addcontentsline{toc}{section}{Referências}
\begin{thebibliography}{200}
\bibitem{datasheetkit} SILICON LABORATORIES; C8051F340DK Datasheet, disponível em: <http://datasheet.octopart.com/C8051F340DK-Silicon-Laboratories-datasheet-9512.pdf>. Acesso em: 09/6/2010.
\bibitem{webcam} GENIUS; iLook 300 - Especificações. Disponível em: <http://www.genius-europe.com/en/produktdetail.php?ID2=83\&ID=31\&ID3=479>. Acesso em: 09/06/2010.
\bibitem{datasheetsensor} SHARP CORPORATION; GP2Y0A02F98YK Datasheet . Disponível em: <http://document.sharpsma.com/files/gp2y0a02yk\_e.pdf>. Acesso em: 09/06/2010
\bibitem{datasheetpclinux} VIA TECHNOLOGIES; EPIA M-Series Mini-ITX Mainboard. Disponível em: <http://www.via.com.tw/servlet/downloadSvl?id=81\&download\_file\_id=3300>. Acesso em:09/06/2010.
\bibitem{datasheetwireless} EDIMAX; EW-7128g PCI Wireless Lan PC Card Datasheet. Disponível em: <http://www.edimax.com/images/Image/datasheet/Wireless/EW-7128g/EW-7128g-Datasheet-10202008.zip>. Acesso em: 09/06/2010.
\bibitem{gpl2} GNU; General Public License V2.0. Disponível em: <http://www.gnu.org/licenses/gpl-2.0.html>. Acesso em: 09/06/2010.
\bibitem{gpl3}
GNU; General Public License V3.0. Disponível em: <http://www.gnu.org/licenses/gpl-3.0.html>. Acesso em: 09/06/2010.
\bibitem{videolan} VideoLAN; VLC media player. Disponível em: <http://www.videolan.org/vlc/>. Acesso em: 09/06/2010.
\bibitem{vlcj} VLCJ; Java Bindings for the VideoLAN Media Player. Disponível em: <http://code.google.com/p/vlcj/>. Acesso em: 09/06/2010.
\bibitem{jna} JNA; Java Native Access. Disponível em: <https://jna.dev.java.net/>. Acesso em: 09/06/2010.
\bibitem{jinput} JAVA Input API. Disponível em: <https://jinput.dev.java.net/>. Acesso em: 09/06/2010.
\bibitem{bsdlicense} Berkley Source Distribution License. Disponível em: <http://www.linfo.org/bsdlicense.html>. Acesso em: 09/06/2010.
\bibitem{lgpl3} GNU; Lesser General Public License. Disponível em: <http://www.gnu.org/licenses/lgpl-3.0.html>. Acesso em: 09/06/2010.
\bibitem{uml} OBJECT MANAGEMENT GROUP; Unified Modeling Language. Disponível em:<http://www.uml.org/>. Acesso em: 09/06/2010.
\end{thebibliography}

\newpage
\emph{\LARGE{Anexo A - Protocolo}}
\normalsize
\addcontentsline{toc}{section}{Anexo A - Protocolo}
\lstset{language=C}
\lstinputlisting{protocolo.h}



\end{document}