\chapter{Conclusão}

Este capítulo apresenta a conclusão da monografia, na qual serão discutidos os objetivos iniciais e os resultados alcançados, as conclusões sobre o uso de algoritmos de navegação em plataformas robóticas reais, as dificuldades encontradas durante o projeto e as sugestões para trabalhos futuros.

\section{Objetivos Iniciais e Resultados Alcançados}

Este projeto surgiu a partir da inspiração em testar, empiricamente, a eficiência de uma metodologia de navegação chamada \emph{Event-Driven Fuzzy Cognitive Maps} (ED-FCM) comparada à metodologia \emph{Fuzzy}, que levou a equipe a desenvolver um trabalho de conclusão de curso com objetivos abrangentes, envolvendo desenvolvimento de \emph{hardware} e \emph{software}. No contexto da navegação robótica, surgiu a necessidade de se utilizar um robô real com a fi\-na\-li\-da\-de de se obterem resultados mais significativos, visto que o ED-FCM não havia ainda sido testado em ambientes reais, apenas em um ambiente simulado. O ambiente simulado da tese de \cite{MENDONCA} não levou em consideração ruídos dos sensores e diferenças mecânicas dos atuadores do robô. No Bellator, os motores DC tinham uma resposta diferente para um derterminado nível de tensão, sendo necessário implementar um ajuste via sistema microcontrolado para manter as velocidades das rodas em um mesmo nível. Outros problemas inerentes ao uso de uma plataforma real puderam ser observados, como a mudança de comportamento dos algoritmos quando a bateria dos motores foi trocada. Com a nova bateria, as ações do robô tornaram-se mais rápidas, exigindo que os algoritmos fossem modificados para manter o movimento suave do robô. Com a finalidade de observar esses efeitos nos algoritmos \emph{Fuzzy} e ED-FCM, foi elaborado um projeto cujo escopo também foi reconstruir e adequar uma plataforma robótica previamente disponível, que é descrita na seção \ref{sec:estpro}, contudo, que não estava em condições de uso imediato. A equipe procedeu com testes em laboratório de eletrônica afim de avaliar as condições iniciais do robô, conforme foi descrito na seção \ref{sec:testecomp}. Uma análise de \emph{software} foi efetuada e o código original do microcontrolador C8051F340DK, disponibilizado como parte integrante do robô Bellator \cite{BELLATOR}, foi avaliado e reconfigurado de acordo com as necessidades do projeto, o que é descrito em detalhes na seção \ref{sec:codmicro}. Havendo necessidade de implementação de \emph{hardware}, a equipe projetou e construiu uma placa de roteamento para alimentar os sensores e \emph{encoders}, assim como tratar os sinais destes e os de PWM, como é descrito na seção \ref{sec:desroteamento}. Finalmente, o \emph{hardware} acoplado foi configurado e o \emph{software} responsável pela execução dos algortimos de navegação foi desenvolvido, conforme a seção \ref{sec:ts}. Com isso, a equipe foi capaz de obter uma plataforma robótica apropriada para o restante do projeto e possíveis utilizações futuras, concluindo a primeira parte do projeto.

Estando a plataforma robótica funcional, seguiram-se o projeto e implementação dos algoritmos de navegação propostos. A Lógica \emph{Fuzzy} foi estudada e apresentada na seção \ref{sec:logfuzzy} e a metodologia \emph{Event-Driven Fuzzy Congnitive Maps} (ED-FCM) foi estudada e apresentada na seção \ref{sec:fcm}, proporcionando à equipe a fundamentação teórica necessária para o desenvolvimento e aprimoramento dos algoritmos. Com a teoria fundamentada, a equipe projetou os algoritmos estudados e implementou-os na linguagem C++, compilando-os para execução na plataforma Linux embarcada da TS-7260, como descrito nas seções \ref{sec:algfuzzy} e \ref{sec:algedfcm}. Após a implementação, a equipe submeteu os algoritmos a uma série de testes básicos, denominada Testes Iniciais, que serviram para fornecer a primeira realimentação do projeto dos algoritmos, que permitiu o ajuste inicial dos mesmos e pode ser lido na seção \ref{sec:testesini}. Finalizados esses testes, foram elaborados testes complexos, denominados Testes Avançados, para estressar os sistemas de navegação propostos e fornecer a segunda realimentação do projeto dos algoritmos, conforme foi descrito na seção \ref{sec:testesavan}, e que permitiu o aprimoramento dos algoritmos até a versão definitiva utilizada para obtenção dos resultados finais. Finalmente, após os testes avançados, os algoritmos resolviam problemas complexos de navegação, como o corredor sem saída e o pro\-ble\-ma de decisão quando dois obstáculos laterais e um frontal eram colocados diante do robô, e poderiam ser usados nos testes finais, que forneceram os dados para a análise de resultados e foram denominados Testes Comparativos, conforme foi descrito na seção \ref{sec:testescomp}. Com isso a equipe concluiu a segunda parte, que foi composta pelo projeto e implementação dos algoritmos de navegação e a elaboração e execução de uma metodologia de testes comparativos entre os algoritmos.

A equipe conclui esta monografia justificando que os objetivos descritos na introdução, seção \ref{rec:obj}, foram alcançados e estão de acordo com os requisitos mínimos de um curso de Engenharia de Computação.

\section{Uso de Algoritmos de Navegação em Plataformas Robóticas Reais}

Através deste trabalho, concluiu-se que os algoritmos de navegação apresentam uma solução para os problemas de navegação em ambientes reais, isto é, as metodologias \emph{Fuzzy} e \emph{ED-FCM} permitiram implementar um controlador capaz de guiar um robô autônomo de maneira que este pudesse desviar obstáculos e evitar a colisão, que é um dos problemas de navegação, conforme explica \cite{FRACASSO}. O uso de um robô real ao invés de uma simulação computacional gerou resultados que contribuem para o estudo proposto. Um robô real apresenta diversos problemas práticos que em uma simulação computacional são dificilmente visualizados. O primeiro problema é a interferência que os sensores de distância podem sofrer apresentando ruídos na saída. Os sensores de distância não são perfeitos e apresentam respostas diferentes dependendo da forma geométrica das superfícies e, como é o caso do sensor infravermelho, até mesmo da cor das superfícies \cite{datasheetsensor}. Outro problema é que os sensores apresentam uma faixa de operação, ou seja, uma distância mínima e máxima possível de serem medidas. Isso significa que os algoritmos devem ser projetados para operar de acordo com essa faixa. No caso do sensor infravermelho utilizado, o 2Y0A02F98 (explicado na seção \ref{sec:sensores}), a faixa de operação suportada é de 20 a 150 centímetros. Dentro dessa faixa, o algoritmo deve gerar necessariamente um comando, caso contrário, o robô perderá o controle pois o sensor fornecerá leituras inconsistentes, principalmente quando a distância for menor que o limite mínimo. Além dos problemas associados aos sensores, a implementação em uma plataforma real demonstrou que as partes mecânicas do robô devem ser incluídas no projeto do sistema de navegação. O robô Bellator possui dois motores DC cuja resposta de velocidade de rotação não é igual quando aplicado um mesmo nível de tensão, isto é, quando aplicado um mesmo nível de PWM aos motores, estes não giram na mesma velocidade. Isso implicou a implementação de um mecanismo de ajuste que permitisse que as duas rodas girassem na mesma velocidade quando necessário. Esse mecanismo é descrito na seção \ref{sec:softwarets}. Outro problema inerente ao uso da plataforma real foi o que aconteceu quando a bateria dos motores foi trocada. Com a bateria nova, a corrente que alimentava os motores era maior e por isso as ações produzidas pelo robô tornaram-se mais intensas. Para manter o movimento do robô suave e evitar colisões por causa de curvas acentuadas, foi necessário reajustar os algoritmos. Concluiu-se que o nível de tensão e carga do sistema de alimentação dos motores do robô deve ser levado em conta no projeto dos algoritmos de navegação.

As conclusões sobre os algoritmos explorados nesse trabalho são que ambos, o algoritmo \emph{Fuzzy} e o ED-FCM, apresentaram comportamentos semelhantes, conforme pode ser observado nas trajetórias das figuras \ref{algtestU_caminhos} e \ref{algtestfinal_caminhos}, e são indicados para utilização em sistemas de navegação robótica. Existem peculiaridades de cada um que podem ser levantadas. O algoritmo ED-FCM apresentou ações rápidas e curvas mais acentuadas que o algoritmo \emph{fuzzy}. Isso porque as sigmóides utilizadas na ativação dos conceitos variam rapidamente do nível 0 para 1, significando que pequenas variações nas distâncias dos sensores produzem grandes variações nos conceitos de nível e, portanto, na potência dos motores. Esse efeito poderia ser reduzido suavizando as sigmóides ou criando mais níveis para os pesos das relações causais. Outra característica do ED-FCM é que essa implementação não necessita da criação de um banco de regras, como é o caso do algoritmo \emph{fuzzy}, e as decisões são calculadas por meio de fórmulas matemáticas e mapeiam a leitura dos sensores diretamente em ações. Também a implementação do ED-FCM não necessitou do uso de uma biblioteca computacional específica, como foi o caso do \emph{fuzzy}, determinando simplicidade de implementação e menor tamanho de código escrito. Por isso, concluiu-se que um ED-FCM poderia ser implementado em uma camada de mais baixo nível, um processador digital de sinais, por exemplo, que desse suporte a operações matemáticas de exponenciação, divisão, multiplicação e soma de números de ponto flutuante. 

Alguns problemas de navegação foram melhor resolvidos pelo algoritmo \emph{fuzzy}, explicando esse fato porque a base de regras permite maior número de ações influenciando a saída do algoritmo, que produz um comportamento mais abrangente e diversificado. O ED-FCM, por outro lado, tem a limitação de apresentar uma quantidade reduzida de conceitos, sendo que o projeto de um mapa com mais conceitos poderia implicar maior complexidade computacional. Um dos problemas observados na depuração do ED-FCM é que o processo de calibração dos pesos das relações causais pode gerar instabilidades. Nenhum método de aprendizado de máquina foi utilizado e os pesos foram determinados manualmente com o procedimentos de tentativa e erro. Por exemplo, a alteração de um peso determinava a mudança do comportamento do robô e, como a antecipação dessa mudança era difícil de ser visualizada, geravam-se resultados indesejados. Por isso o processo de ajuste do ED-FCM foi mais demorado que o do algorimo \emph{fuzzy}. Concluiu-se que o ED-FCM gera resultados mais rapidamente que o \emph{fuzzy} em termos de implementação, entretanto, a manutenção do ED-FCM é mais demorada e complexa que do \emph{fuzzy}. Vale ressaltar que ambos os algoritmos tem vantagens e desvantagens um sobre o outro. O algoritmo \emph{fuzzy} necessita de uma biblioteca específica que implemente a base de regras, necessita da formulação das funções de pertinência e das regras \emph{fuzzy}, tendo como desvantagens maior tamanho de código e tempo de implementação, entretanto, estando esses elementos concluídos, o processo de manutenção do sistema é simples porque os resultados das alteraçãos podem ser antecipados com maior facilidade. 
O ED-FCM apresenta maior simplicidade de implementação e menor tamanho de código porque depende da definição dos conceitos e das relações causais, sendo que os conceitos são ativados através de fórmulas matemáticas. Desse modo, os resultados da implementação de um ED-FCM são mais rápidos, mas a manutenção do sistema é mais complexa porque o efeito da alteração das propriedades do ED-FCM é mais dificilmente visualizado e antecipado. Os dois algoritmos são indicados para uso em uma plataforma robótica real, mesmo apesar dos problemas inerentes a um robô real, o \emph{fuzzy} e o ED-FCM geraram comportamentos adequados de navegação e, cabe salientar, que os comportamentos observados foram previstos no projeto. Isto é, os algoritmos apresentam um comportamento controlável, permitindo projetar sistemas que podem ter usos inclusive mais específicos que o apresentado neste trabalho.

\section{Dificuldades Encontradas}

 Os problemas encontrados na execução do projeto estão associados ao escopo abrangente do mesmo, o qual envolveu o desenvolvimento de \emph{hardware} e \emph{software} em um projeto integrador. A subdivisão do projeto em diversos objetivos, sendo um pré-requisito para o outro, foi inevitável para alcançar os resultados finais. A equipe encontrou dificuldades durante a reconstrução do robô, configuração da placa TS-7260, testes integrados de funcionamento do robô, implementação dos algoritmos, execução dos testes dos algoritmos e análise de resultados. 
 
Durante a reconstrução, os componentes eletrônicos foram testados isoladamente, com risco de existência de componentes danificados, o que representaria atrasos no projeto. A placa TS-7260 apresentou complexidade para ser configurada pois não houve um técnico disponível para auxiliar a equipe, a qual teve que aprender a trabalhar com esse \emph{hardware}. Nos testes de integração da C8051F340DK e da TS-7260, que determinaram o funcionamento da plataforma robótica, foram exigidos processos de depuração integrados, nos quais os problemas foram isolados e corrigidos repetidas vezes. A implementação dos algoritmos até a versão final, que foi utilizada nos testes comparativos, foi realizada paralelamente aos testes básicos e avançados, nas quais os problemas de navegação foram detectados, isolados e corrigidos repetidas vezes. A metodologia de testes escolhida foi elaborada pela equipe e foram efetuados vários experimentos com registro em vídeo até que se atingessem os resultados finais. Tendo com base os vídeos gravados e a experiência em campo observada, a equipe precisou analisar os resultados, discutí-los e extrair conclusões para finalizar o projeto.

\section{Trabalhos Futuros}

Para trabalhos futuros utilizando a plataforma Bellator reconstruída, a equipe recomenda combinar sensores de ultrassom com sensores infravermelhos, pois os sensores de ultrassom apresentam uma faixa de operação cuja distância mínima é menor que a do infravermelho, podendo capturar distâncias de 2 cm, como o sensor SRF06 \cite{SRF06}. Atualmente a distância mínima suportada pelo sistema de navegação é de 15 cm, com os sensores de ultrassom, os algoritmos poderiam operar em uma faixa mais abrangente. Outra su\-ges\-tão é introduzir ao sistema uma realimentação por bússola pois nesse projeto a realimentação odométrica fornecida pelos \emph{encoders} é utilizada para ajustar a velocidade das rodas e não faz uma interpretação da direção do robô. 

Para tornar o robô seguro para o manuseio, sugere-se a fixação dos sensores parafusando-os no chassi do Bellator e acoplando uma carcaça que proteja os circuitos microcontrolados. A equipe também recomenda a reconstrução da placa de roteamento utilizando um método industrial para confeccção de placas de circuito impresso. 

Para os sistemas de navegação, um trabalho futuro de grande riqueza seria introduzir ao sistema a capacidade de interpretar a posição do robô em relação a um referencial. Com isso, o robô seria capaz de resolver problemas nos quais este deve partir de um ponto inicial no espaço a um ponto final, guiando-se pelos sensores para evitar colisões e realimentar-se por um sistema de posicionamento para corrigir a trajetória. 

Outro trabalho, produto deste, seria introduzir ao sistema uma memória a qual pudesse mapear os obstáculos capturados pelos sensores do robô, assim sendo, produzir-se-ia um artefato autônomo capaz de mapear terrenos. Outro aprimoramento da plataforma seria implementar um sistema de controle remoto, na qual uma base remota pudesse pilotar o robô via \emph{joystick} - esta funcionalidade poderia ser usada para treinar o sistema de controle ED-FCM. Finalmente, a equipe sugere um projeto futuro no qual seja implementado um sistema de visão computacional por câmera de vídeo. Sobre os algoritmos, a equipe sugere que os estudos empíricos sejam continuados e que nos próximos trabalhos sejam apresentadas medidas quantitativas de desempenho para ambos algoritmos, \emph{fuzzy} e ED-FCM, justificando a importância que essas medidas teriam na escolha de uma das abordagens no projeto de um sistema de navegação.
