%---------- Segundo Capitulo ----------
\chapter{Desenvolvimento}
\label{chap:desenv}

Este capítulo contém em detalhes o trabalho realizado pela equipe, dividido nas seguintes seções:
\begin{itemize}
    \item[-] Teste dos Componentes: esta seção contém em detalhes quais e em que ordem foram realizados os
     testes de componentes do robô.
    \item[-] Código do microcontrolador C8051F340: contém informações a respeito das mudanças no código do
    microcontrolador.
    \item[-] Placa de roteamento: contém as especificações da placa de roteamento, assim como os motivos
    que levarem a equipe a desenvolver esta placa, o projeto da mesma, e o resultado.
\end{itemize}

\section{Teste dos Componentes}
\label{sec:testecomp}

Após o recebimento do robô, foram realizados testes para garantir a funcionalidade dos componentes recebidos, já que o robô
estava com suas peças empilhadas numa caixa e não era possível confiar no funcionamento adequado de nenhum dos componentes, além de que a falha de alguns componentes implicaria na impossibilidade de continuar o projeto ou em atrasos significativos. Estes testes também foram necessários para determinar de forma mais precisa o que poderia ser reaproveitado do projeto Bellator. De acordo com a documentação do projeto Bellator~\cite{BELLATOR}, o robô deveria ser capaz de, se montado conforme as instruções na mesma, funcionar como um sistema controlado remotamente. Como o objetivo deste projeto não envolve controlar
o robô remotamente, foi testada apenas a camada de baixo nível.

O primeiro passo da etapa de testes foi verificar o funcionamento da placa C8051F340, peça fundamental para o desenvolvimento do projeto, que apresentou o funcionamento adequado, gerando os PWMs dos motores conforme necessário (visualizados no osciloscópio), e realizando a leitura dos sensores e conversão A/D conforme esperado. Em seguida, foram iniciados os testes utilizando a placa de roteamento já existente, que apresentou defeito. Após alguns testes, foi constatado que a placa havia sido desconfigurada, várias soldas foram removidas, o circuito em si estava alterado. Então, a equipe reorganizou a placa, realizou novos testes, mas não obteve sucesso. Foi então verificado que
o regulador de tensão não estava funcionando. Este foi substituído e a placa finalmente funcionou conforme esperado.

Com a placa de roteamento antiga funcionando, foi possível realizar o teste dos motores, utilizando os PWMs gerados pelo
microcontrolador C8051F340 (entrada do buffer da placa de roteamento). Nesse teste, não ocorreram problemas, os motores funcionaram conforme esperado.

Das duas baterias inicialmente disponíveis, uma não estava funcionando conforme a especificação, o que levou a equipe
a adquirir uma nova bateria 12V para reposição da bateria danificada.

Com todos os componentes acima citados testados, o que faltava para completar os testes da camada de baixo nível era apenas
o teste dos encoders. Esta etapa foi uma das mais difíceis, pois a equipe não tinha informação nem do modelo do encoder.
Depois de muito procurar, foi encontrado um datasheet de um encoder equivalente ao presente no robô, datasheet este que foi fundamental para determinar como alimentar e testar o encoder. Em posse da informação de como usar o encoder, o teste foi realizado tanto para o encoder esquerdo como o direito. O encoder direito funcionou normalmente, porém o esquerdo não. Então, a equipe percebeu que a solda dos fios do encoder não estava boa. Após refazer as soldas, o encoder esquerdo foi testado
novamente e funcionou.

Tendo realizado os testes dos componentes mais críticos, o passo seguinte foi tentar utilizar o PC Embarcado VIA EPIA ME6000.
Após muitas tentativas falhas e busca por informações sem resultados, a equipe optou por não utilizar este componente, já que
sua documentação era escassa e o tempo perdido na tentativa de utilizá-la já estava acima do planejado. O PC Embarcado foi substituído pela placa TS-7260, que possui uma documentação muito melhor, poder de processamento superior, e funcionou
nos primeiros testes.

\section{Código do microcontrolador C8051F340}
\label{sec:codmicro}
Uma das necessidades do código do microcontrolador é o tratamento dos sinais dos encoders para obter informações de odometria, informações estas essenciais para a navegação autônoma. O código do projeto Bellator~\cite{BELLATOR} não continha o tratamento
dos sinais dos encoders. Portanto, foi necessário alterar o código do microcontrolador para tratar os sinais
dos encoders e enviar informações de odometria. Para tal, foram utilizadas duas interrupções externas da placa C8051F340 (uma
para cada encoder). Nestas interrupções, cada pulso do encoder é contado (obviamente cada encoder possui seu contador separadamente). A informação de odometria é então enviada através da comunicação serial. Como o encoder dá 1800 pulsos por volta, a resolução é de 360/1800 = 0.2 graus.  Contudo, tamanha precisão é exagerada, e a equipe optou por enviar através apenas uma mensagem (através da porta serial) a cada 180 pulsos do encoder, ou seja, 36 graus de rotação ou um décimo de volta.

\section{Placa de Roteamento}
\label{sec:desroteamento}

A placa de roteamento é um componente fundamental do projeto, responsável por realizar a interligação entre a placa C8051F340 e os componentes de hardware do robô. A equipe constatou a necessidade deste componente devido aos seguintes fatores:

\begin{itemize}
    \item[-] Necessidade de alimentação dedicada para alguns componentes
    \item[-] Necessidade de tratamento dos sinais dos encoders
    \item[-] Roteamento das leituras de cada sensor para o pino I/O correto da C8051F340
    \item[-] Necessidade de um buffer para o PWM
    \item[-] Melhor organização do robô
\end{itemize}

Como descrito nas especificações do robô (\ref{chap:esprob}), o robô Bellator possui, dentre outros componentes, cinco sensores, dois encoders e duas pontes H. Os cinco sensores e dois encoders necessitam de alimentação de aproximadamente 5 Volts para operação. Os encoders produzem um sinal que precisa ser amplificado antes da utilização, e as duas pontes H necessitam de um sinal de PWM de baixa impedância. Além disso, o consumo de corrente total destes componentes ultrapassa a capacidade de fornecimento de corrente da C8051F340. Medições durante os testes com os componentes foram realizadas, e foi constatado que cada sensor de distância utiliza cerca de 30mA de corrente, enquanto os encoders utilizam 20mA cada, totalizando quase 200mA para estes componentes.

Por fim, a dificuldade de conectar, de forma prática, todos os componentes do robô com a C8051F340 bem como a quantidade excessiva de fios resultante fez com que a equipe concluísse que a placa de roteamento é indispensável.

De acordo com os fatores descritos, a equipe construiu uma lista de requisitos para a placa de roteamento:

\begin{itemize}
    \item[-] Fornecer alimentação de aproximadamente 5 Volts DC
    \item[-] Capacidade de corrente suficiente %Atualizar com valores!
    \item[-] Conectores práticos para interface com a C8051F340 e o resto do robô
    \item[-] Fornecer um buffer para o sinal de PWM
    \item[-] Fornecer amplificação para o sinal do encoder
\end{itemize}

Após a análise dos requisitos, a equipe iniciou o desenvolvimento de uma placa de circuito impresso para atender a todos os requisitos. A necessidade de uma alimentação de 5 Volts tornou essencial a utilização de um regulador de tensão, o LM317, que era o mesmo utilizado na versão antiga da placa, e suporta corrente de até 1.5A, valor suficiente para alimentar os componentes da placa. O buffer para o sinal de PWM foi feito através do CI 74LS244N e a amplificação dos sinais dos Encoders utilizando-se um amplificador operacional LM324N. O restante da placa consiste de pinos para conectar cabos flat, para a interação com a C8051F340, bem como pinos para conectores do hardware do robô Bellator. O diagrama esquemático de tal placa foi produzido com o auxílio do software Eagle e o resultado pode ser visualizado a seguir.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.8\textwidth]{./figs/roteamento_sch.png}
  \caption[Diagrama esquemático da placa de roteamento.]
  {Diagrama esquemático da placa de roteamento.}
  \label{fig:roteamento_sch}
\end{figure}

De posse do diagrama esquemático apresentado na figura \ref{roteamentosch} a equipe realizou o roteamento de uma placa de circuito impresso que atenda ao mesmo diagrama esquemático, também utilizando o software Eagle.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.8\textwidth]{./figs/roteamento_brd.png}
  \caption[Roteamento final produzido pela equipe.]
  {Roteamento final produzido pela equipe.}
  \label{fig:roteamento_brd}
\end{figure}

A placa de roteamento foi confeccionada manualmente em uma placa de circuito impresso. O desenho da placa foi impresso em uma folha de transparência A4 e utilzando-se uma impressora à laser. Esse desenho foi passado da trasparência para a placa com o auxílio de um ferro de passar roupa e a placa foi corroída usando-se o percloreto de ferro. A placa foi perfurada com broca e perfurador de placa e os componentes eletrônicos foram soldados com ferro de solda, estanho e pasta de solda. A figura \ref{fig:confeccao} ilustra o processo de confeccção da placa.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=0.8\textwidth]{./figs/placa-confeccao.jpg}
  \caption[Processo de confecção da placa de roteamento.]
  {Processo de confecção da placa de roteamento.}
  \label{fig:confeccao}
\end{figure}

%Descrever os fatores. Escrever requisitos. Descrever placa. Explicar a produção da placa. Por que usar o Eagle.

\section{Placa TS-7260}
\label{sec:ts}
%Descrição do motivo da escolha da placa, implementação de códigos auxiliares aos algoritmos (comunicação, etc)...
Esta seção explicará como foi estruturado o software desenvolvido para a placa
TS-7260, cuja função principal é realizar a interface entre o software do microcontrolador
C8051F340 e o algoritmo de navegação (Fuzzy ou FCM).

\subsection{Configuração da TS-7260}
O software da TS-7260 foi desenvolvido em C++, assim como os algoritmos de navegação, a serem
explicados em detalhes na seção~\ref{sec:algs}. A programação foi realizada em um computador comum.
Para realização de testes na placa, o código foi compilado para a TS-7260 através da utilização de um
\emph{cross-compiler}. O arquivo binário gerado pela compilação foi então movido para uma pasta compartilhada
na rede. Esta pasta foi disponibilizada através de um servidor NFS (\emph{Network File System}) instalado no computador
onde o código foi desenvolvido. A placa TS-7260 contém em um pendrive um linux compilado para a sua
arquitetura, que disponibiliza o cliente nfs, através do qual foi possível montar a pasta compartilhada e rodar
o algoritmo. Posteriormente, para testes totalmente autônomos, o arquivo binário foi copiado da pasta
compartilhada para o pendrive conectado à TS-7260, o que permite que o robô execute a navegação sem
necessidade de conexão com o computador.

Todas as configurações da TS-7260 foram realizadas através de um terminal disponibilizado pela porta
serial. Através de um software como o HyperTerminal (Windows) ou o minicom (Linux) é possível receber/enviar
dados. A placa TS-7260 possui três portas de comunicação serial, das quais duas foram utilizadas:
COM1 e COM2. A porta COM1 foi utilizada para conectar a TS-7260 ao microcontrolador C8051F340, para possibilitar
a troca de mensagens de comando com o microcontrolador (para alterar os níveis de PWM dos motores), assim
como o recebimento das leituras dos sensores. A porta COM2, por sua vez, foi configurada para ser o terminal
mencionado anteriormente. Basta conectar um cabo serial da COM2 da TS-7260 ao computador para utilizá-lo.
As configurações da serial utilizadas foram (tanto COM1 quanto COM2): 115200 8N1, ou seja, \emph{baud-rate}
de 115200, caracteres de 8 (oito) bits, sem bit de paridade e com 1 (um) bit de parada. Através do terminal
disponibilizado na COM2, é possível montar e acessar a pasta de rede compartilhada, conforme descrito no parágrafo
anterior.

\subsection{Software da TS-7260}
O código que roda na TS-7260 é o que efetivamente controla o robô. A parte principal do código consiste
de um loop infinito, que executa os seguintes passos:

\begin{itemize}
	\item Envio de um SYNC para o microcontrolador: isto faz com que o microcontrolador responda
		um pacote com as leituras mais recentes dos sensores de distância, juntamente com as leituras
		dos encoders (esta comunicação é realizada via porta serial);
	\item Leitura do pacote enviado pelo microcontrolador: recebe os dados do microcontrolador e
		os armazena;
	\item Execução do algoritmo de navegação: utiliza os dados armazenados para executar o algoritmo
		de navegação, passando os valores de leitura dos sensores de distância. O algoritmo utiliza
		os dados para realizar a inferência, retornando valores que indicam qual ação o robô deve tomar;
	\item Ajuste dos setpoints: nesta etapa, os dados retornados pelo algoritmo de navegação são
		utilizados para o cálculo do setpoint de cada roda (velocidade desejada), o setpoint é então
		alterado de acordo;
	\item Ajuste de velocidade: esta etapa consiste do ajuste dos níveis de PWM de cada roda, e utiliza
		para tal os valores de leitura dos encoders e o setpoint do passo anterior.
		O objetivo do ajuste de velocidade é fazer com que cada motor fique o mais próximo possível
		do setpoint estabelecido previamente;
	\item Envio das ações: os níveis de PWM definidos pelo ajuste de velocidade são enviados para
		o microcontrolador C8051F340, que efetiva a mudança.
\end{itemize}

O diagrama em blocos a seguir representa o funcionamento do software, demonstrando
também em que etapas ocorre a comunicação com o microcontrolador e quando o algoritmo
de navegação é executado.

\tikzstyle{tsb} = [rectangle, draw=black!100, fill=blue!15!green!10,
    text width=8em, text centered, rounded corners, minimum height=1cm]
\tikzstyle{transition} = [rectangle, thick, draw=black!75, fill=black!20,
	minimum size=4mm]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{8051b} = [rectangle, draw=black!100, fill=red!15, rounded corners,
	minimum height=1cm, text width=8em, text centered]
\tikzstyle{navb} = [rectangle, draw=black!100, fill=yellow!30, rounded corners,
	text width=8em, minimum height=1cm, text centered]
\tikzstyle{background} = [rectangle, fill=gray!50, inner sep=4mm, rounded corners=5mm]

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance = 1.5cm, auto]
		% Nós e conexões do diagrama
		\node [tsb] (opentty) {Configura serial};
		\node [tsb, below of=opentty] (sync) {Envia SYNC} edge [pre] (opentty);
		\node [tsb, below of=sync] (read) {Leitura do pacote} edge [pre] (sync);
		\node [tsb, below of=read] (alg) {Executa algoritmo de navegação} edge [pre] (read);
		\node [navb, left=2cm of alg] (nrcv) {Recebe dados} edge [pre, dashed] (alg);
		\node [navb, below of=nrcv] (ninf) {Realiza a inferência} edge [pre] (nrcv);
		\node [navb, below of=ninf] (nret) {Retorna as ações} edge [pre] (ninf);
		\node [tsb, right=2cm of nret] (sadj) {Ajuste dos setpoints} edge [pre, dashed] (nret);
		\node [tsb, below of=sadj] (vadj) {Ajuste da velocidade} edge [pre] (sadj);
		\node [tsb, below of=vadj] (act) {Envia as ações} edge [pre] (vadj);
		\node [tsb, below of=act] (end) {Loop} edge [pre] (act);
		\node [8051b, right=2cm of sync] (rcv) {Recebe SYNC} edge [pre, dashed] (sync);
		\node [8051b, below of=rcv] (spkg) {Envia pacote}
			edge [pre] (rcv)
			edge [post, dashed] (read);
		\node [8051b, right=2cm of act] (pwm) {Ajuste dos PWMs} edge [pre, dashed] (act);
		\path [line] (end) -- +(-2.5,0) |- (sync);
		% Background
		\begin{pgfonlayer}{background}
			\node [background, fit=(opentty) (end), label=above:tslogic] {};
			\node [background, fit=(nrcv) (nret), label=above:Fuzzy/FCM] {};
			\node [background, fit=(rcv) (pwm), label=above:C8051F340] {};
		\end{pgfonlayer}
	\end{tikzpicture}
	\caption[Diagrama em blocos software TS-7260]
	{Diagrama em blocos demonstrando o funcionamento do software da placa TS-7260.}
\end{figure}

\section{Algoritmos de Navegação}
\label{sec:algs}
Esta seção dedica-se à descrição da implementação dos algoritmos de navegação conforme descrição teórica dos mesmos apresentada na fundamentação teórica. Mais específicamente, serão descritos os códigos responsáveis pela tomada de decisões de ambos os algoritmos de navegação que executam na placa TS-7260, o algoritmo de navegação de lógica Fuzzy simples e o ED-FCM.

\subsection{Algoritmo de Navegação Fuzzy}
\label{sec:algfuzzy}
%Descrição e referencia básica da biblioteca do fabro, adaptação e utilização. Descrição das regras. INCOMPLETO
O algoritmo de Navegação Fuzzy, baseado em inferências sobre conjuntos Fuzzy, foi desenvolvido utilizando-se a biblioteca FLIE, desenvolvida originalmente pelo professor João Alberto Fabro. A FLIE, ou \emph{Fuzzy Logic Inference Engine}, é uma biblioteca que já implementa um ambiente para a definição de conjuntos fuzzy e regras de inferência sobre os mesmos, proporcionando à equipe mais tempo para o aprimoramento das regras e conjuntos e o teste dos mesmos. Este algoritmo será utilizado como base de comparação para determinação da eficiência do ED-FCM, descrito na seção \ref{sec:algedfcm}. Nesta seção, será descrito como a biblioteca FLIE foi utilizada neste projeto e como foram definidos os conjuntos fuzzy e as regras de inferência, seguindo a fundamentação teórica sobre o assunto apresentada na seção \ref{sec:logfuzzy}.

\subsubsection{Variáveis Linguísticas}
\label{sec:devarling}
A biblioteca FLIE, desenvolvida em C++ por Jõao Alberto Fabro, possui estruturas de dados, ou classes, prontas para serem utilizadas para definição de variáveis linguísticas para bem como estruturas para a definição de regras de inferência baseadas neste conjunto de variáveis linguísticas, sendo apropriada para a elaboração de um algoritmo de navegação fuzzy. A biblioteca funciona de acordo com os princípios teóricos fuzzy apresentados na seção \ref{sec:logfuzzy}.

Para elaborar o controle fuzzy responsável pelo algoritmo de navegação, é necessário, primeiramente, definir as variáveis linguísticas e os conjuntos fuzzy associados às mesmas. Em seguida, deve-se definir as variáveis linguísticas de entrada e saída do sistema e as associar apropriadamente. Em seguida, é necessário definir o método de defuzzificação e, finalmente, as regras de inferência. Cada um destes passos será descrito em detalhes a seguir.
 
A biblioteca FLIE permite a definição de variáveis linguísticas na classe \emph{linguisticvariable}, que pode ser composta por diversos conjuntos fuzzy, definidos a partir da classe \emph{category}. Cada \emph{category} é definida por uma faixa de valores válidos (\emph{range}), por 4 pontos que definem um trapézio com os intervalos de subida, máximo e descida do nível de pertinência do conjunto de entrada, para fuzzificação dos dados, e um nome apropriado, tal como Perto, Longe, Rápido, dependendo do contexto. Ou seja, cada valor de entrada é fuzzificado de acordo com seu nível de pertinência a cada categoria (conjunto fuzzy) pertencente à variável linguística. A figura \ref{lingvar}, apresentada a seguir, demonstra de forma gráfica esta estrutura.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{./figs/lingvar.png}
  \caption[Estrutura de uma Variável Linguística no FLIE.]
  {Estrutura de uma Variável Linguística no FLIE.}
  \label{lingvar}
\end{figure}

Utilizando esta estrutura, foram desenvolvidas três variáveis linguísticas para a entrada do sistema e duas variáveis linguísticas para a saída do sistema. Deve-se observar que foram definidas apenas três variáveis linguísticas de entrada por dois motivos: A biblioteca FLIE não aceita mais que três entradas em uma regra de inferência e um número maior de entradas levaria à uma quantidade excessiva de regras de inferência. As variáveis linguísticas de entrada correspondem aos cinco sensores do robô, sendo que o sensor frontal utiliza uma variável linguística, ``SensorFrente" e os dois pares de sensores laterais são agrupados em duas variáveis linguísticas, ``SensorEsquerda" e ``SensorDireita" sendo que apenas o menor valor de leitura válida é selecionado nos pares de sensores laterais para ser fuzzificado. Cada uma destas variáveis linguísticas está definida com três conjuntos fuzzy, totalizando nove conjuntos fuzzy organizados de acordo com a tabela \ref{tab:varsfuzzy}.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
  \hline
  % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
  \textbf{Variável Linguística} & \textbf{Conjunto Fuzzy} & \textbf{Função de Pertinência} \\
  \hline
  SensorEsquerda & PertoEsquerda & p(d) \\
  \hline
  SensorEsquerda & MedioEsquerda & m(d) \\
  \hline
  SensorEsquerda & LongeEsquerda & l(d) \\
  \hline
  SensorFrente & Perto & p(d) \\
  \hline
  SensorFrente & Medio & m(d) \\
  \hline
  SensorFrente & Longe & l(d) \\
  \hline
  SensorDireita & PertoDireita & p(d) \\
  \hline
  SensorDireita & MedioDireita & m(d) \\
  \hline
  SensorDireita & LongeDireita & l(d) \\
  \hline
\end{tabular}
\caption[Funções de Pertinência e Conjuntos Fuzzy dos Sensores]{Funções de Pertinência e Conjuntos Fuzzy dos Sensores.}
\label{tab:varsfuzzy}
\end{table}
As funções de pertinência p(d), m(d), l(d), correspondentes a perto, médio e longe, são definitas pelos trapézios da figura \ref{fuzzygraph_des}:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{./figs/fuzzygraph_des.png}
  \caption[Definição das Funções de Pertinência perto, médio e longe.]
  {Definição das Funções de Pertinência perto, médio e longe.}
  \label{fuzzygraph_des}
\end{figure}

Embora as função de pertinência sejam a mesma para os conjuntos fuzzy representando perto, médio e longe para as três variáveis linguísticas, cada variável linguística necessita de objetos da classe \emph{category} exclusivos e únicos, por uma restrição da biblioteca flie, e não é possível utilizar o mesmo conjunto fuzzy para duas ou mais variáveis linguísticas diferentes.

De forma análoga, as variáveis linguísticas de saída do sistema são definidas pelas variáveis linguísticas ``Velocidade Motor" e ``Direção", representando a velocidade e a direção do deslocamento do robô. Os conjuntos fuzzy associados à variável linguística Velocidade Motor foram definidos de forma a distribuir igualmente as faixas de pwm de 0 a 100\% da capacidade do motor em três categorias: Lento, Médio e Rápido. As funções de pertinência que definem estes conjuntos fuzzy são l(p), m(p), r(p), onde p é a percentagem do pwm. Pode-se visualizar estas funções na figura \ref{defuzzygraph_velmotor}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{./figs/defuzzygraph_velmotor.png}
  \caption[Definição das Funções de Pertinência lento, médio e rápido.]
  {Definição das Funções de Pertinência lento, médio e rápido.}
  \label{defuzzygraph_velmotor}
\end{figure}

Similarmente, foram definidos 5 conjuntos fuzzy para a variável linguística ``Direção": ViraEsquerda, ViraPoucoEsquerda, Reto, ViraPoucoDireita, ViraDireita, distribuindo igualmente entre estas classes todas as possibilidades de direção, desde virar totalmente para a esquerda (0º) até totalmente para direita(180º). As funções de pertinência que definem estes conjuntos fuzzy são ve(a), vpe(a), r(a), vpd(a), vd(a). O gráfico em \ref{defuzzygraph_ang} ilustra estas funções.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{./figs/defuzzygraph_ang.png}
  \caption[Definição das Funções de Pertinência de Direção]
  {Definição das Funções de Pertinência de Direção.}
  \label{defuzzygraph_ang}
\end{figure}


\subsubsection{Regras de Inferência}

Após definidas as variáveis linguísticas, regras de inferência podem ser elaboradas através da classe \emph{infrule}. Esta classe é composta de, no máximo, três variáveis linguísticas de entrada e uma variável linguística de saída, todas definidas pela classe \emph{linguisticvariable}, seguindo a estrutura na figura \ref{infrule}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{./figs/infrule.png}
  \caption[Estrutura de uma regra de inferência no FLIE.]
  {Estrutura de uma regra de inferência no FLIE.}
  \label{infrule}
\end{figure}

Com as variáveis linguísticas de entrada e saída pode-se criar regras de inferência. Primeiramente, é necessário associar as variáveis linguísticas que compõe as regras de inferência de entrada e saída à um objeto da classe \emph{fuzzy\_control}. Em seguida, cada regra é definida por uma sequência de valores fuzzy pertencentes às variáveis linguísticas de entrada e saída associadas com o objeto da classe \emph{fuzzy\_control}, sendo o último valor da sequência a saída fuzzy desejada para uma entrada correspondente aos um, dois ou três valores antecedentes, que é o limite de entradas da biblioteca FLIE, como mencionado em \ref{sec:devarling}. Como deseja-se obter duas saídas, uma para a velocidade e outra para a direção, foram necessários dois objetos desta classe, ambos com as mesmas entradas. Além disso, é necessário definir o método de defuzzificação a ser utilizado pelo controle fuzzy. A equipe utilizou o método da Média do Máximo, descrito na seção \ref{sec:fuzzycontrol}. Assim, as regras de inferência seguem padrão abaixo, de acordo com as variáveis linguísticas definidas em \ref{sec:devarling}:
\begin{center}
SensorEsquerda, SensorFrente, SensorDireita, Velocidade Motor\\
SensorEsquerda, SensorFrente, SensorDireita, Direção
\end{center}

Em seguida, pode-se definir as regras através dos valores fuzzy válidos para cada variável linguística associada aos objetos \emph{fuzzy\_control}. A definição das regras é bastante intuitiva, empírica e altamente dependente da aplicação. A equipe optou por definir um conjunto de regras arbitrário, realizar testes e, analisando os resultados preliminares, aprimorar o conjunto de regras. A tabela \ref{tab:regrasinf} representa o conjunto definitivo de 27 regras elaboradas pela equipe, que correspondem a todas as combinações possíveis de entradas para o controle fuzzy.

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{SensorEsquerda} & \textbf{SensorFrente} & \textbf{SensorDireita} & \textbf{VelocidadeMotor} & \textbf{Direção} \\
\hline
PertoEsquerda & Perto & PertoDireita & Lento & ViraDireita \\
\hline
PertoEsquerda & Perto & MedioDireita & Lento & ViraDireita \\
\hline
PertoEsquerda & Perto & LongeDireita & Lento & ViraDireita \\
\hline
PertoEsquerda & Medio & PertoDireita & Lento & Reto \\
\hline
PertoEsquerda & Medio & MedioDireita & Lento & ViraPoucoDireita \\
\hline
PertoEsquerda & Medio & LongeDireita & Lento & ViraPoucoDireita \\
\hline
PertoEsquerda & Longe & PertoDireita & Medio & Reto \\
\hline
PertoEsquerda & Longe & MedioDireita & Lento & ViraPoucoDireita \\
\hline
PertoEsquerda & Longe & LongeDireita & Lento & ViraPoucoDireita \\
\hline
MedioEsquerda & Perto & PertoDireita & Lento & ViraEsquerda \\
\hline
MedioEsquerda & Perto & MedioDireita & Lento & ViraPoucoDireita \\
\hline
MedioEsquerda & Perto & LongeDireita & Lento & ViraPoucoDireita \\
\hline
MedioEsquerda & Medio & PertoDireita & Lento & ViraPoucoEsquerda \\
\hline
MedioEsquerda & Medio & MedioDireita & Medio & Reto \\
\hline
MedioEsquerda & Medio & LongeDireita & Medio & Reto \\
\hline
MedioEsquerda & Longe & PertoDireita & Lento & ViraPoucoEsquerda \\
\hline
MedioEsquerda & Longe & MedioDireita & Rapido & Reto \\
\hline
MedioEsquerda & Longe & LongeDireita & Medio & Reto \\
\hline
LongeEsquerda & Perto & PertoDireita & Lento & ViraEsquerda \\
\hline
LongeEsquerda & Perto & MedioDireita & Lento & ViraPoucoEsquerda \\
\hline
LongeEsquerda & Perto & LongeDireita & Lento & ViraPoucoDireita \\
\hline
LongeEsquerda & Medio & PertoDireita & Lento & ViraPoucoEsquerda \\
\hline
LongeEsquerda & Medio & MedioDireita & Medio & Reto \\
\hline
LongeEsquerda & Medio & LongeDireita & Medio & Reto \\
\hline
LongeEsquerda & Longe & PertoDireita & Lento & ViraPoucoEsquerda \\
\hline
LongeEsquerda & Longe & MedioDireita & Medio & Reto \\
\hline
LongeEsquerda & Longe & LongeDireita & Rapido & Reto \\
\hline
\end{tabular}
\caption[Regras de Inferência - Algoritmo Fuzzy]{Regras de Inferência - Algoritmo Fuzzy.}
\label{tab:regrasinf}
\end{table}

Finalmente, as regras definidas podem ser utilizadas para realizar as inferências. A bilioteca FLIE recebe os dados de entrada não fuzzificados, os fuzzifica, atribuindo valores de pertinência para cada categoria definida pelo desenvolvedor e determina o nível de ativação de cada regra de inferência definida. Após esta etapa, a FLIE defuzzifica o resultado seguindo o modelo de defuzzificação escolhido e retorna o resultado final, que pode ser utilizado para controlar a navegação do robô.

\subsection{Algoritmo de Navegação Baseado em FCM}
\label{sec:algedfcm}
%Descrição da adaptação do código matlab, utilização, conceitos.
Esta seção tem por objetivo descrever o projeto e a implementação do algoritmo de navegação baseado na abordage FCM, apresentada na seção \ref{sec:fcm} da fundamentação teórica. O projeto consistiu na definição dos conceitos de entrada, nível e saída, relações causais e respectivos pesos. A implementação foi desenvolvida em linguagem C++ e compilada para ser executada na placa TS-7260.

A idéia do algoritmo foi controlar a direção do robô ajustando a potência aplicada em cada roda, de forma independente, sendo que esta pode ser aplicada para a roda girar em ambos os sentidos. As seguintes hipóteses foram elaboradas para projetar o algoritmo:

\begin{enumerate}
\item Quando o robô detectar um objeto à esquerda, aquele deve desviar para a direita.
\item Quando o robô detectar um objeto à direita, aquele deve desviar para a esquerda.
\item Quando o robô não detectar objetos nas laterais, este deve seguir em frente.
\end{enumerate}

Os movimentos "desviar para a direita", "desviar para a esquerda" e "seguir em frente" podem ser obtidos controlando-se a potência e o sentido aplicado em cada roda. Desse modo, duas hipóteses foram imaginadas: as duas rodas girando para frente e as duas rotas girando em sentidos opostos. Os movimentos produzidos na primeira situação são:

\begin{enumerate}
\item Quando a roda direita girar mais rápido que a roda esquerda, a mudança de direção é "desviar para a esquerda".
\item Quando a roda esquerda girar mais rápido que a roda direita, a mudança de direção é "desviar para a direita".
\item Quando a roda esquerda girar na mesma intensidade que a roda direita, o movimento é "seguir em frente".
\end{enumerate}

Os movimentos produzidos na segunda situação são:
\begin{enumerate}
\item Quando a roda direita girar para frente e a roda esquerda girar para trás, o movimento é "desviar para a esquerda".
\item Quando a roda esquerda girar para frente e a roda direita girar para trás, o movimento é "desviar para a direita".
\end{enumerate}

Desse modo, o algoritmo controla a direção do robô calculando a "intensidade de girar" a roda direita para trás ou para frente e a "intensidade de girar" a roda esquerda para trás ou para frente, sendo que esse cálculo recebe como entradas as distâncias registradas pelos sensores de distância na lateral direita, na frente e na lateral esquerda do robô.

Primeiramente, definiu-se a entrada do sistema de navegação, a qual correspondeu às leituras dos sensores de distância. Desse modo, foram criados três conceitos de entrada:

\begin{enumerate}
\item SE - Representa a leitura do sensor lateral esquerdo.
\item SF - Representa a leitura do sensor frontal.
\item SD - Representa a leitura do sensor lateral direito.
\end{enumerate}

Esses conceitos guardam o valor da leitura da distância normalizada na faixa de 0 a 1, através da equação \ref{eq:normaliza}, sendo x o valor absoluto da distância (cm), MIN o valor mínimo suportado pelo sensor e MAX o valor máximo.

\begin{equation}
\label{eq:normaliza}
y=\frac {x-MIN} {MAX-MIN}
\end{equation}

Em seguida, foram determinados os conceitos de nível do FCM, os quais estabelecem as inferências resultantes dos valores dos conceitos de entrada. Foram definidos quatro conceitos de nível:

\begin{enumerate}
\item GDF - Representa a intensidade da decisão de girar a roda direita para frente.
\item GDT - Representa a intensidade da decisão de girar a roda direita para trás.
\item GEF - Representa a intensidade da decisão de girar a roda esquerda para frente.
\item GET - Representa a intensidade da decisão de girar a roda esquerda para trás.
\end{enumerate}

Os níveis desses conceitos são ativados através de uma função sigmoidal dependente dos valores dos conceitos de entrada. As equações \ref{eq:sig_frente} e \ref{eq:sig_tras} foram adaptadas da equação \ref{sigmoide}, apresentada na fundamentação teórica, e operam em domínio (0, 1) e imagem (0, 1).

\begin{equation}
\label{eq:sig_frente}
f_1(x)=\frac{1} {1+e^{(-10x+4,5)}}
\end{equation}

\begin{equation}
\label{eq:sig_tras}
f_2(x)=1-\frac{1} {1+e^{(-10x+4,5)}}
\end{equation}

Por fim, definiu-se a saída do sistema de navegação, a qual são os níveis percentuais de potência de cada roda. Esse nível varia na faixa de -100\% a +100\% e o sinal indica o sentido de giro, sendo o sinal positivo "girar para frente" e o sinal negativo "girar para trás". Desse modo, foram estabelecidos dois conceitos de saída:

\begin{enumerate}
\item RD Out - Representa o nível percentual de potência da roda direita.
\item RE Out - Representa o nível percentual de potência da roda esquerda.
\end{enumerate}

\begin{table}[htb!]
	\centering
	\caption[Relações causais do controlador FCM proposto]{Relações causais do controlador FCM proposto.}		
	\begin{tabular}[!htb]{ l l l l }
	  \hline
	  Relação causal & Descrição & Efeito & Intensidade \\
	  \hline
		$w_1$ & SD influencia GDF & Positivo & Forte \\
		$w_2$ & SD influencia GEF & Negativo & Fraca \\
		$w_3$ & SD influencia GET & Positivo & Média \\
		
		$w_4$ & SE influencia GEF & Positivo & Forte \\
		$w_5$ & SE influencia GDF & Negativo & Fraca \\
		$w_6$ & SE influencia GDT & Positivo & Média \\
		
		$w_7$ & SF influencia GDF & Negativo & Forte \\
		$w_8$ & SF influencia GDT & Positivo & Fraca \\
		$w_9$ & SF influencia GEF & Negativo & Forte \\
		$w_{10}$ & SF influencia GET & Positivo & Fraca \\
		
		$w_{11}$ & GDF influencia RD Out & Positivo & Forte \\
		$w_{12}$ & GDT influencia RD Out & Negativo & Média \\
		$w_{13}$ & GEF influencia RE Out & Positivo & Forte \\
		$w_{14}$ & GET influencia RE Out & Negativo & Média \\
	  \hline  	
	\end{tabular}
	\label{tab:fcm-relacoes}
\end{table}

\begin{table}[htb!]
	\centering
	\caption[Valor numérico dos pesos]{Valor numérico dos pesos.}		
	\begin{tabular}[!htb]{ l l l l }
	  \hline
	  Intensidade & Valor numérico \\
	  \hline
		FRACA & 0,125 \\
		MÉDIA & 0,5 \\
		FORTE & 1,0 \\
	  \hline  	
	\end{tabular}
	\label{tab:pesos}
\end{table}

\begin{figure}
	\centering
	\begin{tikzpicture}[node distance=1.3cm,>=stealth',bend angle=45,auto]

		\tikzstyle{place}=[circle,thick,draw=black!75,fill=blue!30,minimum size=6mm]
		\tikzstyle{red place}=[place,draw=red!75,fill=red!20]
		\tikzstyle{transition}=[rectangle,thick,draw=black!75,
			fill=black!20,minimum size=4mm]

		\tikzstyle{every label}=[red]
		\tikzstyle{weight}=[rectangle,draw=black!75,minimum size=5mm]

		\node [place, fill=red!30] (SE) {SE};
		\node [place, below=1cm of SE] (SF) {SF};
		\node [place, fill=green!30, below=1cm of SF] (SD) {SD};
		\node [place, fill=orange!30, below right=.75cm and 4cm of SD] (GET) {GET};
		\node [place, fill=orange!30, above=1cm of GET] (GEF) {GEF};
		\node [place, fill=orange!30, right=2cm of GEF] (REO) {RE Out};
		\node [place, fill=yellow!30, above right=.75cm and 4cm of SE] (GDT) {GDT};
		\node [place, fill=yellow!30, below=1cm of GDT] (GDF) {GDF};
		\node [place, fill=yellow!30, right=2cm of GDF] (RDO) {RD Out};
		\node [weight, fill=blue!30, left=1cm of GEF] (w9) {w9}
			edge [thick] (SF)
			edge [post,thick] (GEF);
		\node [weight, fill=green!30, below=.2cm of w9] (w2) {w2}
			edge [thick] (SD)
			edge [post,thick] (GEF);
		\node [weight, fill=green!30, left=1cm of GET] (w3) {w3}
			edge [thick] (SD)
			edge [post,thick] (GET);
		\node [weight, fill=red!30, above=.2cm of w9] (w4) {w4}
			edge [thick] (SE)
			edge [post,thick] (GEF);
		\node [weight, fill=red!30, left=1cm of GDT] (w6) {w6}
			edge [thick] (SE)
			edge [post,thick] (GDT);
		\node [weight, fill=blue!30, left=1cm of GDF] (w7) {w7}
			edge [thick] (SF)
			edge [post,thick] (GDF);
		\node [weight, fill=green!30, below=.2cm of w7] (w1) {w1}
			edge [thick] (SD)
			edge [post,thick] (GDF);
		\node [weight, fill=red!30, above=.2cm of w7] (w5) {w5}
			edge [thick] (SE)
			edge [post,thick] (GDF);
		\node [weight, fill=blue!30, below=.2cm of w6] (w8) {w8}
			edge [thick] (SF)
			edge [post,thick] (GDT);
		\node [weight, fill=blue!30, above=.2cm of w3] (w10) {w10}
			edge [thick] (SF)
			edge [post,thick] (GET);
		\node [weight, fill=yellow!30, left=.5cm of RDO] (w11) {w11}
			edge [thick] (GDF)
			edge [post,thick] (RDO);
		\node [weight, fill=yellow!30, above=.5cm of w11] (w12) {w12}
			edge [thick] (GDT)
			edge [post,thick] (RDO);
		\node [weight, fill=orange!30, left=.5cm of REO] (w13) {w13}
			edge [thick] (GEF)
			edge [post,thick] (REO);
		\node [weight, fill=orange!30, below=.5cm of w13] (w14) {w14}
			edge [thick] (GET)
			edge [post,thick] (REO);
	\end{tikzpicture}
	\caption[FCM proposto]{FCM proposto.}
	\fonte{Autoria própria.}
	\label{fig:fcm-proposto}
\end{figure}

Os conceitos foram interligados através das relações causais apresentadas na tabela \ref{tab:fcm-relacoes}, obtendo-se o mapa da figura \ref{fig:fcm-proposto}, e o valor numérico dos pesos está de acordo com a tabela \ref{tab:pesos}. As equações \ref{eq:gdf} a \ref{eq:get} determinam as intensidades dos conceitos de nível e as equações \ref{eq:rd_out} e \ref{eq:re_out} estabelecem a saída do FCM.

\begin{equation}
\label{eq:gdf}
GDF=\frac {w_1f_2(SD)+w_5f_1(SE)-w_7f_2(SF)} {w_1+w_5}
\end{equation}

\begin{equation}
\label{eq:gdt}
GDT=\frac {w_6f_2(SE)+w_8f_2(SF)} {w_6+w_8}
\end{equation}

\begin{equation}
\label{eq:gef}
GEF=\frac {w_4f_2(SE)+w_2f_1(SD)-w_9f_2(SF)} {w_4+w_2}
\end{equation}

\begin{equation}
\label{eq:get}
GET=\frac {w_3f_2(SE)+w_{10}f_2(SF)} {w_3+w_{10}}
\end{equation}

\begin{equation}
\label{eq:rd_out}
RD_{Out}=100 \times \frac {w_{11}GDF-w_{12}GDT} {FORTE}
\end{equation}

\begin{equation}
\label{eq:re_out}
RD_{Out}=100 \times \frac {w_{13}GEF-w_{14}GET} {FORTE}
\end{equation}

O algoritmo FCM projetado conecta os conceitos de entrada SD, SF e SE, através dos conceitos de nível GDF, GDT, GEF e GET, aos conceitos de saída RD Out e RE Out. Os conceitos de nível são ativados gradualmente através dos valores normalizados dos conceitos de entrada, sendo que essa ativação herda a característica de suavidade das funções sigmoidais \ref{eq:sig_frente} e \ref{eq:sig_tras}. Os conceitos de saída são uma média ponderada entre os conceitos "girar para frente" e "girar para trás", aplicada a cada roda. O comportamente esperado desse algoritmo é que o robô desvie obstáculos de forma suave e responda instantaneamente à leitura dos sensores de distância.

\section{Considerações}
Nesta seção foram descritos os passos da equipe desde os testes iniciais com o robô até o projeto da nova placa de roteamento. Com a realização destas tarefas, o objetivo de reconstrução da camada de baixo nível do robô Bellator foi alcançado.
