%---------- Segundo Capitulo ----------
\chapter{Desenvolvimento}
\label{chap:desenv}

Este capítulo contém em detalhes o trabalho realizado pela equipe, dividido nas seguintes seções:
\begin{itemize}
    \item[-] Teste dos Componentes: esta seção contém em detalhes quais e em que ordem foram realizados os
     testes de componentes do robô.
    \item[-] Código do microcontrolador C8051F340: contém informações a respeito das mudanças no código do
    microcontrolador.
    \item[-] Placa de roteamento: contém as especificações da placa de roteamento, assim como os motivos
    que levarem a equipe a desenvolver esta placa, o projeto da mesma, e o resultado.
\end{itemize}

\section{Teste dos Componentes}
\label{sec:testecomp}

Após o recebimento do robô, foram realizados testes para garantir a funcionalidade dos componentes recebidos, já que o robô
estava com suas peças empilhadas numa caixa e não era possível confiar no funcionamento adequado de nenhum dos componentes, além de que a falha de alguns componentes implicaria na impossibilidade de continuar o projeto ou em atrasos significativos. Estes testes também foram necessários para determinar de forma mais precisa o que poderia ser reaproveitado do projeto Bellator. De acordo com a documentação do projeto Bellator~\cite{BELLATOR}, o robô deveria ser capaz de, se montado conforme as instruções na mesma, funcionar como um sistema controlado remotamente. Como o objetivo deste projeto não envolve controlar
o robô remotamente, foi testada apenas a camada de baixo nível.

O primeiro passo da etapa de testes foi verificar o funcionamento da placa C8051F340, peça fundamental para o desenvolvimento do projeto, que apresentou o funcionamento adequado, gerando os PWMs dos motores conforme necessário (visualizados no osciloscópio), e realizando a leitura dos sensores e conversão A/D conforme esperado. Em seguida, foram iniciados os testes utilizando a placa de roteamento já existente, que apresentou defeito. Após alguns testes, foi constatado que a placa havia sido desconfigurada, várias soldas foram removidas, o circuito em si estava alterado. Então, a equipe reorganizou a placa, realizou novos testes, mas não obteve sucesso. Foi então verificado que
o regulador de tensão não estava funcionando. Este foi substituído e a placa finalmente funcionou conforme esperado.

Com a placa de roteamento antiga funcionando, foi possível realizar o teste dos motores, utilizando os PWMs gerados pelo
microcontrolador C8051F340 (entrada do buffer da placa de roteamento). Nesse teste, não ocorreram problemas, os motores funcionaram conforme esperado.

Das duas baterias inicialmente disponíveis, uma não estava funcionando conforme a especificação, o que levou a equipe
a adquirir uma nova bateria 12V para reposição da bateria danificada.

Com todos os componentes acima citados testados, o que faltava para completar os testes da camada de baixo nível era apenas
o teste dos encoders. Esta etapa foi uma das mais difíceis, pois a equipe não tinha informação nem do modelo do encoder.
Depois de muito procurar, foi encontrado um datasheet de um encoder equivalente ao presente no robô, datasheet este que foi fundamental para determinar como alimentar e testar o encoder. Em posse da informação de como usar o encoder, o teste foi realizado tanto para o encoder esquerdo como o direito. O encoder direito funcionou normalmente, porém o esquerdo não. Então, a equipe percebeu que a solda dos fios do encoder não estava boa. Após refazer as soldas, o encoder esquerdo foi testado
novamente e funcionou.

Tendo realizado os testes dos componentes mais críticos, o passo seguinte foi tentar utilizar o PC Embarcado VIA EPIA ME6000.
Após muitas tentativas falhas e busca por informações sem resultados, a equipe optou por não utilizar este componente, já que
sua documentação era escassa e o tempo perdido na tentativa de utilizá-la já estava acima do planejado. O PC Embarcado foi substituído pela placa TS-7260, que possui uma documentação muito melhor, poder de processamento superior, e funcionou
nos primeiros testes.

\section{Código do microcontrolador C8051F340}
\label{sec:codmicro}
Uma das necessidades do código do microcontrolador é o tratamento dos sinais dos encoders para obter informações de odometria, informações estas essenciais para a navegação autônoma. O código do projeto Bellator~\cite{BELLATOR} não continha o tratamento
dos sinais dos encoders. Portanto, foi necessário alterar o código do microcontrolador para tratar os sinais
dos encoders e enviar informações de odometria. Para tal, foram utilizadas duas interrupções externas da placa C8051F340 (uma
para cada encoder). Nestas interrupções, cada pulso do encoder é contado (obviamente cada encoder possui seu contador separadamente). A informação de odometria é então enviada através da comunicação serial. Como o encoder dá 1800 pulsos por volta, a resolução é de 360/1800 = 0.2 graus.  Contudo, tamanha precisão é exagerada, e a equipe optou por enviar através apenas uma mensagem (através da porta serial) a cada 180 pulsos do encoder, ou seja, 36 graus de rotação ou um décimo de volta.

\section{Placa de Roteamento}
\label{sec:desroteamento}

A placa de roteamento é um componente fundamental do projeto, responsável por realizar a interligação entre a placa C8051F340 e os componentes de hardware do robô. A equipe constatou a necessidade deste componente devido aos seguintes fatores:

\begin{itemize}
    \item[-] Necessidade de alimentação dedicada para alguns componentes
    \item[-] Necessidade de tratamento dos sinais dos encoders
    \item[-] Roteamento das leituras de cada sensor para o pino I/O correto da C8051F340
    \item[-] Necessidade de um buffer para o PWM
    \item[-] Melhor organização do robô
\end{itemize}

Como descrito nas especificações do robô (\ref{chap:esprob}), o robô Bellator possui, dentre outros componentes, cinco sensores, dois encoders e duas pontes H. Os cinco sensores e dois encoders necessitam de alimentação de aproximadamente 5 Volts para operação. Os encoders produzem um sinal que precisa ser amplificado antes da utilização, e as duas pontes H necessitam de um sinal de PWM de baixa impedância. Além disso, o consumo de corrente total destes componentes ultrapassa a capacidade de fornecimento de corrente da C8051F340. Medições durante os testes com os componentes foram realizadas, e foi constatado que cada sensor de distância utiliza cerca de 30mA de corrente, enquanto os encoders utilizam 20mA cada, totalizando quase 200mA para estes componentes.

Por fim, a dificuldade de conectar, de forma prática, todos os componentes do robô com a C8051F340 bem como a quantidade excessiva de fios resultante fez com que a equipe concluísse que a placa de roteamento é indispensável.

De acordo com os fatores descritos, a equipe construiu uma lista de requisitos para a placa de roteamento:

\begin{itemize}
    \item[-] Fornecer alimentação de aproximadamente 5 Volts DC
    \item[-] Capacidade de corrente suficiente %Atualizar com valores!
    \item[-] Conectores práticos para interface com a C8051F340 e o resto do robô
    \item[-] Fornecer um buffer para o sinal de PWM
    \item[-] Fornecer amplificação para o sinal do encoder
\end{itemize}

Após a análise dos requisitos, a equipe iniciou o desenvolvimento de uma placa de circuito impresso para atender a todos os requisitos. A necessidade de uma alimentação de 5 Volts tornou essencial a utilização de um regulador de tensão, o LM317, que era o mesmo utilizado na versão antiga da placa, e suporta corrente de até 1.5A, valor suficiente para alimentar os componentes da placa. O buffer para o sinal de PWM foi feito através do CI 74LS244N e a amplificação dos sinais dos Encoders utilizando-se um amplificador operacional LM324N. O restante da placa consiste de pinos para conectar cabos flat, para a interação com a C8051F340, bem como pinos para conectores do hardware do robô Bellator. O diagrama esquemático de tal placa foi produzido com o auxílio do software Eagle e o resultado pode ser visualizado a seguir.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\textwidth]{./figs/roteamento_sch.png}
  \caption[Diagrama esquemático da placa de roteamento.]
  {Diagrama esquemático da placa de roteamento.}
  \label{fig:roteamento_sch}
\end{figure}

De posse do diagrama esquemático apresentado na figura \ref{roteamentosch} a equipe realizou o roteamento de uma placa de circuito impresso que atenda ao mesmo diagrama esquemático, também utilizando o software Eagle.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\textwidth]{./figs/roteamento_brd.png}
  \caption[Roteamento final produzido pela equipe.]
  {Roteamento final produzido pela equipe.}
  \label{fig:roteamento_brd}
\end{figure}

A placa de roteamento foi confeccionada manualmente em uma placa de circuito impresso. O desenho da placa foi impresso em uma folha de transparência A4 e utilzando-se uma impressora à laser. Esse desenho foi passado da trasparência para a placa com o auxílio de um ferro de passar roupa e a placa foi corroída usando-se o percloreto de ferro. A placa foi perfurada com broca e perfurador de placa e os componentes eletrônicos foram soldados com ferro de solda, estanho e pasta de solda. A figura \ref{fig:confeccao} ilustra o processo de confeccção da placa.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\textwidth]{./figs/placa-confeccao.jpg}
  \caption[Processo de confecção da placa de roteamento.]
  {Processo de confecção da placa de roteamento.}
  \label{fig:confeccao}
\end{figure}

%Descrever os fatores. Escrever requisitos. Descrever placa. Explicar a produção da placa. Por que usar o Eagle.

\section{Placa TS-7260}
%Descrição do motivo da escolha da placa, implementação de códigos auxiliares aos algoritmos (comunicação, etc)...
Esta seção explicará como foi estruturado o software desenvolvido para a placa
TS-7260, cuja função é realizar a interface entre o software do microcontrolador
C8051F340 e o algoritmo de navegação (Fuzzy ou FCM). 

O código que roda na TS-7260 é o que efetivamente controla o robô. A parte principal do código consiste
de um loop infinito, que executa os seguintes passos:

\begin{itemize}
	\item Envio de um SYNC para o microcontrolador: isto faz com que o microcontrolador responda
		um pacote com as leituras mais recentes dos sensores de distância, juntamente com as leituras
		dos encoders (esta comunicação é realizada via porta serial);
	\item Leitura do pacote enviado pelo microcontrolador: recebe os dados do microcontrolador e 
		os armazena;
	\item Execução do algoritmo de navegação: utiliza os dados armazenados para executar o algoritmo
		de navegação, passando os valores de leitura dos sensores de distância. O algoritmo utiliza
		os dados para realizar a inferência, retornando valores que indicam qual ação o robô deve tomar;
	\item Ajuste dos setpoints: nesta etapa, os dados retornados pelo algoritmo de navegação são
		utilizados para o cálculo do setpoint de cada roda (velocidade desejada), o setpoint é então
		alterado de acordo;
	\item Ajuste de velocidade: esta etapa consiste do ajuste dos níveis de PWM de cada roda, e utiliza
		para tal os valores de leitura dos encoders e o setpoint do passo anterior. 
		O objetivo do ajuste de velocidade é fazer com que cada motor fique o mais próximo possível
		do setpoint estabelecido previamente;
	\item Envio das ações: os níveis de PWM definidos pelo ajuste de velocidade são enviados para
		o microcontrolador C8051F340, que efetiva a mudança.
\end{itemize}

O diagrama em blocos a seguir representa o funcionamento do software, demonstrando
também em que etapas ocorre a comunicação com o microcontrolador e quando o algoritmo 
de navegação é executado.

\tikzstyle{tsb} = [rectangle, draw=black!100, fill=blue!15!green!10, 
    text width=8em, text centered, rounded corners, minimum height=1cm]
\tikzstyle{transition} = [rectangle, thick, draw=black!75, fill=black!20,
	minimum size=4mm]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{8051b} = [rectangle, draw=black!100, fill=red!15, rounded corners,
	minimum height=1cm, text width=8em, text centered]
\tikzstyle{navb} = [rectangle, draw=black!100, fill=yellow!30, rounded corners,
	text width=8em, minimum height=1cm, text centered]
\tikzstyle{background} = [rectangle, fill=gray!50, inner sep=4mm, rounded corners=5mm];
    
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance = 1.5cm, auto]
		% Nós e conexões do diagrama
		\node [tsb] (opentty) {Configura serial};
		\node [tsb, below of=opentty] (sync) {Envia SYNC} edge [pre] (opentty);
		\node [tsb, below of=sync] (read) {Leitura do pacote} edge [pre] (sync);
		\node [tsb, below of=read] (alg) {Executa algoritmo de navegação} edge [pre] (read);
		\node [navb, left=2cm of alg] (nrcv) {Recebe dados} edge [pre, dashed] (alg);
		\node [navb, below of=nrcv] (ninf) {Realiza a inferência} edge [pre] (nrcv);
		\node [navb, below of=ninf] (nret) {Retorna as ações} edge [pre] (ninf);
		\node [tsb, right=2cm of nret] (sadj) {Ajuste dos setpoints} edge [pre, dashed] (nret);
		\node [tsb, below of=sadj] (vadj) {Ajuste da velocidade} edge [pre] (sadj);
		\node [tsb, below of=vadj] (act) {Envia as ações} edge [pre] (vadj);
		\node [tsb, below of=act] (end) {Loop} edge [pre] (act);
		\node [8051b, right=2cm of sync] (rcv) {Recebe SYNC} edge [pre, dashed] (sync);
		\node [8051b, below of=rcv] (spkg) {Envia pacote} 
			edge [pre] (rcv)
			edge [post, dashed] (read);
		\node [8051b, right=2cm of act] (pwm) {Ajuste dos PWMs} edge [pre, dashed] (act);
		\path [line] (end) -- +(-2.5,0) |- (sync);
		% Background
		\begin{pgfonlayer}{background}
			\node [background, fit=(opentty) (end), label=above:tslogic] {};
			\node [background, fit=(nrcv) (nret), label=above:Fuzzy/FCM] {};
			\node [background, fit=(rcv) (pwm), label=above:C8051F340] {};
		\end{pgfonlayer}
	\end{tikzpicture}
	\caption[Diagrama em blocos software TS-7260]
	{Diagrama em blocos demonstrando o funcionamento do software da placa TS-7260.}
\end{figure}

\section{Algoritmos de Navegação}
\label{sec:algs}
Esta seção dedica-se à descrição da implementação dos algoritmos de navegação conforme descrição teórica dos mesmos apresentada na fundamentação teórica. Mais específicamente, serão descritos os códigos responsáveis pela tomada de decisões de ambos os algoritmos de navegação que executam na placa TS-7260, o algoritmo de navegação de lógica Fuzzy simples e o ED-FCM.

\subsection{Algoritmo de Navegação Fuzzy}
\label{sec:algfuzzy}
%Descrição e referencia básica da biblioteca do fabro, adaptação e utilização. Descrição das regras. INCOMPLETO
O algoritmo de Navegação Fuzzy, baseado em inferências sobre conjuntos Fuzzy, foi desenvolvido utilizando-se a biblioteca FLIE, desenvolvida originalmente pelo professor João Alberto Fabro. A FLIE, ou \emph{Fuzzy Logic Inference Engine}, é uma biblioteca que já implementa um ambiente para a definição de conjuntos fuzzy e regras de inferência sobre os mesmos, proporcionando à equipe mais tempo para o aprimoramento das regras e conjuntos e o teste dos mesmos. Este algoritmo será utilizado como base de comparação para determinação da eficiência do ED-FCM, descrito na seção \ref{sec:algedfcm}. Nesta seção, será descrito como a biblioteca FLIE foi utilizada neste projeto e como foram definidos os conjuntos fuzzy e as regras de inferência.

\subsubsection{Variáveis Linguísticas}

A biblioteca FLIE possui estruturas de dados, ou classes, prontas para serem utilizadas para definição de variáveis linguísticas para a construção de um conjunto de variáveis fuzzy, bem como estruturas para a definição de regras de inferência baseadas neste conjunto de variáveis fuzzy.
A engine permite a definição de variáveis linguísticas na classe \emph{linguisticvariable}, que pode ser classificada através de valores fuzzy, com a classe \emph{category}. Cada \emph{category} é definida por uma faixa de valores válidos (\emph{range}), por 4 pontos que definem um trapézio com os intervalos de subida, máximo e descida do nível de pertinência do conjunto de entrada, para fuzzificação dos dados, e um nome apropriado, tal como Perto, Longe, Rápido, dependendo do contexto. Ou seja, cada valor de entrada é fuzzificado de acordo com um nível de pertinência a cada categoria pertencente à variável linguística. A figura \ref{lingvar}, apresentada a seguir, demonstra de forma gráfica esta estrutura.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\textwidth]{./figs/lingvar.png}
  \caption[Estrutura de uma Variável Linguística no FLIE.]
  {Estrutura de uma Variável Linguística no FLIE.}
  \label{lingvar}
\end{figure}

Utilizando esta estrutura, foram desenvolvidas três variáveis linguísticas para a entrada do sistema e duas variáveis linguísticas para a saída do sistema. As variáveis linguísticas de entrada correspondem aos cinco sensores do robô... %testes..

\subsubsection{Regras de Inferência}

Após definidas as variáveis linguísticas, regras de inferência podem ser elaboradas através da classe \emph{infrule}. Esta classe é composta de, no máximo, três variáveis linguísticas de entrada e uma variável linguística de saída, todas definidas pela classe \emph{linguisticvariable}, seguindo a estrutura na figura \ref{infrule}.

\begin{figure}[!htb]
  \centering
  \includegraphics[width=\textwidth]{./figs/infrule.png}
  \caption[Estrutura de uma regra de inferência no FLIE.]
  {Estrutura de uma regra de inferência no FLIE.}
  \label{infrule}
\end{figure}

Com as variáveis linguísticas de entrada e saída pode-se criar regras de inferência. Cada regra é composta por uma sequência de valores fuzzy, sendo o último valor da sequência a saída fuzzy desejada para uma entrada correspondente aos um, dois ou três valores antecedentes. Considerando esta limitação à três variáveis, ... %unificação dos sensores, definição das regras

Finalmente, as regras definidas podem ser utilizadas para realizar inferências. A bilioteca FLIE recebe os dados de entrada não fuzzificados, os fuzzifica, atribuindo valores de pertinência para cada categoria definida pelo desenvolvedor, determina o nível de ativação de cada regra de inferência definida e defuzzifica o resultado final de forma transparente.

\subsection{Algoritmo de Navegação Baseado em ED-FCM}
\label{sec:algedfcm}
%Descrição da adaptação do código matlab, utilização, conceitos.
Esta seção tem por objetivo descrever o projeto e a implementação do algoritmo de navegação baseado na abordage FCM, apresentada na seção \ref{sec:fcm} da fundamentação teórica. O projeto consistiu na definição dos conceitos de entrada, nível e saída, relações causais e respectivos pesos. A implementação foi desenvolvida em linguagem C++ e compilada para ser executada na placa TS-7260.

Primeiramente, definiu a entrada do sistema de navegação, a qual correspondeu às leituras dos sensores de distância. Desse modo, foram criados três conceitos de entrada:

\begin{enumerate}
\item SD - Representa a leitura do sensor lateral esquerdo.
\item SF - Representa a leitura do sensor frontal.
\item SE - Representa a leitura do sensor lateral direito.
\end{enumerate}

Esses conceitos guardam o valor da leitura da distância normalizada na faixa de 0 a 1, através da equação \ref{eq:normaliza}, sendo x o valor absoluto da distância (cm), MIN o valor mínimo suportado pelo sensor e MAX o valor máximo.

\begin{equation}
\label{eq:normaliza}
y=\frac {x-MIN} {MAX-MIN}
\end{equation}

Em seguida, foram determinados os conceitos de nível do FCM, os quais estabelecem as inferências resultantes dos valores dos conceitos de entrada. Foram definidos quatro conceitos nível:

\begin{enumerate}
\item GDF - Representa a intensidade da decisão de girar a roda direita para frente.
\item GDT - Representa a intensidade da decisão de girar a roda direita para trás.
\item GEF - Representa a intensidade da decisão de girar a roda esquerda para frente.
\item GET - Representa a intensidade da decisão de girar a roda esquerda para trás.
\end{enumerate}

Os níveis desses conceitos são ativados através de uma função sigmoidal dependente dos valores dos conceitos de entrada. As equações \ref{eq:sig_frente} e \ref{eq:sig_tras} foram adaptadas da equação \ref{sigmoide}, apresentada na fundamentação teórica, e operam em domínio (0, 1) e imagem (0, 1).

\begin{equation}
\label{eq:sig_frente}
f_1(x)=\frac{1} {1+e^{(-10x+4,5)}}
\end{equation}

\begin{equation}
\label{eq:sig_tras}
f_2(x)=1-\frac{1} {10+e^{(-10x+4,5)}}
\end{equation}

Por fim, definiu-se a saída do sistema de navegação, a qual são os níveis percentuais de potência de cada roda. Esse nível varia na faixa de -100\% a +100\% e o sinal indica o sentido de giro, sendo o sinal positivo "girar para frente" e o sinal negativo "girar para trás". Desse modo, foram estabelecidos dois conceitos de saída:

\begin{enumerate}
\item RD Out - Representa o nível percentual de potência da roda direita.
\item RE Out - Representa o nível percentual de potência da roda esquerda.
\end{enumerate}

\begin{table}[htb!]
	\centering
	\caption[Relações causais do controlador FCM proposto]{Relações causais do controlador FCM proposto.}		
	\begin{tabular}[!htb]{ l l l l }
	  \hline
	  Relação causal & Descrição & Efeito & Intensidade \\
	  \hline
		$w_1$ & SD influencia GDF & Positivo & Forte \\
		$w_2$ & SD influencia GEF & Negativo & Fraca \\
		$w_3$ & SD influencia GET & Positivo & Forte \\
		
		$w_4$ & SE influencia GEF & Positivo & Forte \\
		$w_5$ & SE influencia GDF & Negativo & Fraca \\
		$w_6$ & SE influencia GDT & Positivo & Forte \\
		
		$w_7$ & SF influencia GDF & Negativo & Fraca \\
		$w_8$ & SF influencia GDT & Positivo & Média \\
		$w_9$ & SF influencia GEF & Negativo & Fraca \\
		$w_{10}$ & SF influencia GET & Positivo & Média \\
		
		$w_{11}$ & GDF influencia RD Out & Positivo & Forte \\
		$w_{12}$ & GDT influencia RD Out & Negativo & Forte \\
		$w_{13}$ & GEF influencia RE Out & Positivo & Forte \\
		$w_{14}$ & GET influencia RE Out & Negativo & Forte \\
	  \hline  	
	\end{tabular}
	\label{tab:fcm-relacoes}
\end{table}

\begin{table}[htb!]
	\centering
	\caption[Valor numérico dos pesos]{Valor numérico dos pesos.}		
	\begin{tabular}[!htb]{ l l l l }
	  \hline
	  Intensidade & Valor numérico \\
	  \hline
		FRACA & 0,125 \\
		MÉDIA & 0,5 \\
		FORTE & 1,0 \\
	  \hline  	
	\end{tabular}
	\label{tab:pesos}
\end{table}

\begin{figure}[!htb]
    \centering
    \includegraphics[scale=0.70]{./figs/fcm_proposto.png}
    \caption[FCM proposto]{FCM proposto.}
    \fonte{\cite{FCMENDONCA}}
    \label{fig:fcm-proposto}
\end{figure}

Os conceitos foram interligados através das relações causais apresentadas na tabela \ref{tab:fcm-relacoes}, obtendo-se o mapa da figura \ref{fig:fcm-proposto}, e o valor numérico dos pesos está de acordo com a tabela \ref{tab:pesos}. As equações \ref{eq:gdf} a \ref{eq:get} determinam as intensidades dos conceitos de nível e as equações \ref{eq:rd_out} e \ref{eq:re_out} estabelecem a saída do FCM.

\begin{equation}
\label{eq:gdf}
GDF=\frac {w_1f_2(SD)+w_5f_1(SE)-w_7f_2(SF)} {w_1+w_5}
\end{equation}

\begin{equation}
\label{eq:gdt}
GDT=\frac {w_6f_2(SE)+w_8f_2(SF)} {w_6+w_8}
\end{equation}

\begin{equation}
\label{eq:gef}
GEF=\frac {w_4f_2(SE)+w_2f_1(SD)-w_9f_2(SF)} {w_4+w_2}
\end{equation}

\begin{equation}
\label{eq:get}
GET=\frac {w_3f_2(SE)+w_{10}f_2(SF)} {w_3+w_{10}}
\end{equation}

\begin{equation}
\label{eq:rd_out}
RD_{Out}=100 \times \frac {w_{11}GDF-w_{12}GDT} {FORTE}
\end{equation}

\begin{equation}
\label{eq:re_out}
RD_{Out}=100 \times \frac {w_{13}GEF-w_{14}GET} {FORTE}
\end{equation}

\section{Considerações}
Nesta seção foram descritos os passos da equipe desde os testes iniciais com o robô até o projeto da nova placa de roteamento. Com a realização destas tarefas, o objetivo de reconstrução da camada de baixo nível do robô Bellator foi alcançado.
