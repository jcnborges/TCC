C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 1   


C51 COMPILER V8.18, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: c:\SiLabs\MCU\IDEfiles\C51\BIN\C51.exe main.c DB OE BR CD SB LC OR LARGE

line level    source

   1          #include "reg52_ext.h"              /* define 8052 registers */
   1      =1  //-----------------------------------------------------------------------------
   2      =1  // c8051F340.h
   3      =1  //-----------------------------------------------------------------------------
   4      =1  // Copyright 2005 Silicon Laboratories, Inc.
   5      =1  // http://www.silabs.com
   6      =1  //
   7      =1  // Program Description:
   8      =1  //
   9      =1  // Register/bit definitions for the C8051F34x family.
  10      =1  //
  11      =1  //
  12      =1  // FID:            34X000000
  13      =1  // Target:         C8051F340, 'F341, 'F342, 'F343, 'F344, 'F345, 'F346, 'F347,
  14      =1  //                 'F348, 'F349, 'F34A, 'F34B
  15      =1  // Tool chain:     Keil
  16      =1  // Command Line:   None
  17      =1  //
  18      =1  // Release 1.2 - 16 SEP 2008 (PKC)
  19      =1  //    -Added 'F348/9/A/B to the target part numbers list.
  20      =1  //
  21      =1  // Release 1.1
  22      =1  //    -All changes by GP
  23      =1  //    -17 NOV 2005
  24      =1  //    -Converted file to new coding guidelines
  25      =1  //    -Added #defines for interrupt priorities
  26      =1  //    -Added #ifndef/#define to allow multiple includes of file
  27      =1  //    -Converted Bit Definitions to absolute addresses for easier porting
  28      =1  //
  29      =1  // Release 1.0
  30      =1  //    -Initial Revision (CM)
  31      =1  //    -08 AUG 2005
  32      =1  //    -Latest release before new firmware coding standard
  33      =1  //
  34      =1  
  35      =1  #ifndef C8051F340_H
  36      =1  #define C8051F340_H
  37      =1  
  38      =1  //-----------------------------------------------------------------------------
  39      =1  // Byte Registers
  40      =1  //-----------------------------------------------------------------------------
  41      =1  
  42      =1  sfr  P0           =  0x80;             // Port 0 Latch
  43      =1  sfr  SP           =  0x81;             // Stack Pointer
  44      =1  sfr  DPL          =  0x82;             // Data Pointer Low
  45      =1  sfr  DPH          =  0x83;             // Data Pointer High
  46      =1  sfr  EMI0TC       =  0x84;             // EMIF Timing
  47      =1  sfr  EMI0CF       =  0x85;             // EMIF Configuration
  48      =1  sfr  OSCLCN       =  0x86;             // Internal Low-Freq Oscillator Control
  49      =1  sfr  PCON         =  0x87;             // Power Control
  50      =1  sfr  TCON         =  0x88;             // Timer/Counter Control
  51      =1  sfr  TMOD         =  0x89;             // Timer/Counter Mode
  52      =1  sfr  TL0          =  0x8A;             // Timer/Counter 0 Low
  53      =1  sfr  TL1          =  0x8B;             // Timer/Counter 1 Low
  54      =1  sfr  TH0          =  0x8C;             // Timer/Counter 0 High
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 2   

  55      =1  sfr  TH1          =  0x8D;             // Timer/Counter 1 High
  56      =1  sfr  CKCON        =  0x8E;             // Clock Control
  57      =1  sfr  PSCTL        =  0x8F;             // Program Store R/W Control
  58      =1  sfr  P1           =  0x90;             // Port 1 Latch
  59      =1  sfr  TMR3CN       =  0x91;             // Timer/Counter 3Control
  60      =1  sfr  TMR3RLL      =  0x92;             // Timer/Counter 3 Reload Low
  61      =1  sfr  TMR3RLH      =  0x93;             // Timer/Counter 3 Reload High
  62      =1  sfr  TMR3L        =  0x94;             // Timer/Counter 3Low
  63      =1  sfr  TMR3H        =  0x95;             // Timer/Counter 3 High
  64      =1  sfr  USB0ADR      =  0x96;             // USB0 Indirect Address Register
  65      =1  sfr  USB0DAT      =  0x97;             // USB0 Data Register
  66      =1  sfr  SCON0        =  0x98;             // UART0 Control
  67      =1  sfr  SBUF0        =  0x99;             // UART0 Data Buffer
  68      =1  sfr  CPT1CN       =  0x9A;             // Comparator1 Control
  69      =1  sfr  CPT0CN       =  0x9B;             // Comparator0 Control
  70      =1  sfr  CPT1MD       =  0x9C;             // Comparator1 Mode Selection
  71      =1  sfr  CPT0MD       =  0x9D;             // Comparator0 Mode Selection
  72      =1  sfr  CPT1MX       =  0x9E;             // Comparator1 MUX Selection
  73      =1  sfr  CPT0MX       =  0x9F;             // Comparator0 MUX Selection
  74      =1  sfr  P2           =  0xA0;             // Port 2 Latch
  75      =1  sfr  SPI0CFG      =  0xA1;             // SPI Configuration
  76      =1  sfr  SPI0CKR      =  0xA2;             // SPI Clock Rate Control
  77      =1  sfr  SPI0DAT      =  0xA3;             // SPI Data
  78      =1  sfr  P0MDOUT      =  0xA4;             // Port 0 Output Mode Configuration
  79      =1  sfr  P1MDOUT      =  0xA5;             // Port 1 Output Mode Configuration
  80      =1  sfr  P2MDOUT      =  0xA6;             // Port 2 Output Mode Configuration
  81      =1  sfr  P3MDOUT      =  0xA7;             // Port 3 Output Mode Configuration
  82      =1  sfr  IE           =  0xA8;             // Interrupt Enable
  83      =1  sfr  CLKSEL       =  0xA9;             // Clock Select
  84      =1  sfr  EMI0CN       =  0xAA;             // External Memory Interface Control
  85      =1  sfr  SBCON1       =  0xAC;             // UART1 Baud Rate Generator Control
  86      =1  sfr  P4MDOUT      =  0xAE;             // Port 4 Output Mode Configuration
  87      =1  sfr  PFE0CN       =  0xAF;             // Prefetch Engine Control
  88      =1  sfr  P3           =  0xB0;             // Port 3 Latch
  89      =1  sfr  OSCXCN       =  0xB1;             // External Oscillator Control
  90      =1  sfr  OSCICN       =  0xB2;             // Internal Oscillator Control
  91      =1  sfr  OSCICL       =  0xB3;             // Internal Oscillator Calibration
  92      =1  sfr  SBRLL1       =  0xB4;             // UART1 Baud Rate Generator Low
  93      =1  sfr  SBRLH1       =  0xB5;             // UART1 Baud Rate Generator High
  94      =1  sfr  FLSCL        =  0xB6;             // Flash Scale
  95      =1  sfr  FLKEY        =  0xB7;             // Flash Lock and Key
  96      =1  sfr  IP           =  0xB8;             // Interrupt Priority
  97      =1  sfr  CLKMUL       =  0xB9;             // Clock Multiplier
  98      =1  sfr  AMX0N        =  0xBA;             // AMUX0 Negative Channel Select
  99      =1  sfr  AMX0P        =  0xBB;             // AMUX0 Positive Channel Select
 100      =1  sfr  ADC0CF       =  0xBC;             // ADC0 Configuration
 101      =1  sfr  ADC0L        =  0xBD;             // ADC0 Low
 102      =1  sfr  ADC0H        =  0xBE;             // ADC0 High
 103      =1  sfr  SMB0CN       =  0xC0;             // SMBus Control
 104      =1  sfr  SMB0CF       =  0xC1;             // SMBus Configuration
 105      =1  sfr  SMB0DAT      =  0xC2;             // SMBus Data
 106      =1  sfr  ADC0GTL      =  0xC3;             // ADC0 Greater-Than Compare Low
 107      =1  sfr  ADC0GTH      =  0xC4;             // ADC0 Greater-Than Compare High
 108      =1  sfr  ADC0LTL      =  0xC5;             // ADC0 Less-Than Compare Word Low
 109      =1  sfr  ADC0LTH      =  0xC6;             // ADC0 Less-Than Compare Word High
 110      =1  sfr  P4           =  0xC7;             // Port 4 Latch
 111      =1  sfr  TMR2CN       =  0xC8;             // Timer/Counter 2 Control
 112      =1  sfr  REG0CN       =  0xC9;             // Voltage Regulator Control
 113      =1  sfr  TMR2RLL      =  0xCA;             // Timer/Counter 2 Reload Low
 114      =1  sfr  TMR2RLH      =  0xCB;             // Timer/Counter 2 Reload High
 115      =1  sfr  TMR2L        =  0xCC;             // Timer/Counter 2 Low
 116      =1  sfr  TMR2H        =  0xCD;             // Timer/Counter 2 High
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 3   

 117      =1  sfr  PSW          =  0xD0;             // Program Status Word
 118      =1  sfr  REF0CN       =  0xD1;             // Voltage Reference Control
 119      =1  sfr  SCON1        =  0xD2;             // UART1 Control
 120      =1  sfr  SBUF1        =  0xD3;             // UART1 Data Buffer
 121      =1  sfr  P0SKIP       =  0xD4;             // Port 0 Skip
 122      =1  sfr  P1SKIP       =  0xD5;             // Port 1 Skip
 123      =1  sfr  P2SKIP       =  0xD6;             // Port 2 Skip
 124      =1  sfr  USB0XCN      =  0xD7;             // USB0 Transceiver Control
 125      =1  sfr  PCA0CN       =  0xD8;             // PCA0 Control
 126      =1  sfr  PCA0MD       =  0xD9;             // PCA0 Mode
 127      =1  sfr  PCA0CPM0     =  0xDA;             // PCA0 Module 0 Mode Register
 128      =1  sfr  PCA0CPM1     =  0xDB;             // PCA0 Module 1 Mode Register
 129      =1  sfr  PCA0CPM2     =  0xDC;             // PCA0 Module 2 Mode Register
 130      =1  sfr  PCA0CPM3     =  0xDD;             // PCA0 Module 3 Mode Register
 131      =1  sfr  PCA0CPM4     =  0xDE;             // PCA0 Module 4 Mode Register
 132      =1  sfr  P3SKIP       =  0xDF;             // Port 3 Skip
 133      =1  sfr  ACC          =  0xE0;             // Accumulator
 134      =1  sfr  XBR0         =  0xE1;             // Port I/O Crossbar Control 0
 135      =1  sfr  XBR1         =  0xE2;             // Port I/O Crossbar Control 1
 136      =1  sfr  XBR2         =  0xE3;             // Port I/O Crossbar Control 2
 137      =1  sfr  IT01CF       =  0xE4;             // INT0/INT1 Configuration
 138      =1  sfr  SMOD1        =  0xE5;             // UART1 Mode
 139      =1  sfr  EIE1         =  0xE6;             // Extended Interrupt Enable 1
 140      =1  sfr  EIE2         =  0xE7;             // Extended Interrupt Enable 2
 141      =1  sfr  ADC0CN       =  0xE8;             // ADC0 Control
 142      =1  sfr  PCA0CPL1     =  0xE9;             // PCA0 Capture 1 Low
 143      =1  sfr  PCA0CPH1     =  0xEA;             // PCA0 Capture 1 High
 144      =1  sfr  PCA0CPL2     =  0xEB;             // PCA0 Capture 2 Low
 145      =1  sfr  PCA0CPH2     =  0xEC;             // PCA0 Capture 2 High
 146      =1  sfr  PCA0CPL3     =  0xED;             // PCA0 Capture 3 Low
 147      =1  sfr  PCA0CPH3     =  0xEE;             // PCA0 Capture 3 High
 148      =1  sfr  RSTSRC       =  0xEF;             // Reset Source Configuration/Status
 149      =1  sfr  B            =  0xF0;             // B Register
 150      =1  sfr  P0MDIN       =  0xF1;             // Port 0 Input Mode Configuration
 151      =1  sfr  P1MDIN       =  0xF2;             // Port 1 Input Mode Configuration
 152      =1  sfr  P2MDIN       =  0xF3;             // Port 2 Input Mode Configuration
 153      =1  sfr  P3MDIN       =  0xF4;             // Port 3 Input Mode Configuration
 154      =1  sfr  P4MDIN       =  0xF5;             // Port 4 Input Mode Configuration
 155      =1  sfr  EIP1         =  0xF6;             // Extended Interrupt Priority 1
 156      =1  sfr  EIP2         =  0xF7;             // Extended Interrupt Priority 2
 157      =1  sfr  SPI0CN       =  0xF8;             // SPI0 Control
 158      =1  sfr  PCA0L        =  0xF9;             // PCA0 Counter Low
 159      =1  sfr  PCA0H        =  0xFA;             // PCA0 Counter High
 160      =1  sfr  PCA0CPL0     =  0xFB;             // PCA0 Capture 0 Low
 161      =1  sfr  PCA0CPH0     =  0xFC;             // PCA0 Capture 0 High
 162      =1  sfr  PCA0CPL4     =  0xFD;             // PCA0 Capture 4 Low
 163      =1  sfr  PCA0CPH4     =  0xFE;             // PCA0 Capture 4 High
 164      =1  sfr  VDM0CN       =  0xFF;             // VDD Monitor Control
 165      =1  
 166      =1  
 167      =1  //-----------------------------------------------------------------------------
 168      =1  // Bit Definitions
 169      =1  //-----------------------------------------------------------------------------
 170      =1  
 171      =1  // TCON 0x88
 172      =1  sbit TF1     = 0x8F;                   // Timer1 overflow flag
 173      =1  sbit TR1     = 0x8E;                   // Timer1 on/off control
 174      =1  sbit TF0     = 0x8D;                   // Timer0 overflow flag
 175      =1  sbit TR0     = 0x8C;                   // Timer0 on/off control
 176      =1  sbit IE1     = 0x8B;                   // Ext interrupt 1 edge flag
 177      =1  sbit IT1     = 0x8A;                   // Ext interrupt 1 type
 178      =1  sbit IE0     = 0x89;                   // Ext interrupt 0 edge flag
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 4   

 179      =1  sbit IT0     = 0x88;                   // Ext interrupt 0 type
 180      =1  
 181      =1  // SCON0 0x98
 182      =1  sbit S0MODE  = 0x9F;                   // Serial mode control bit 0
 183      =1                                         // Bit6 UNUSED
 184      =1  sbit MCE0    = 0x9D;                   // Multiprocessor communication enable
 185      =1  sbit REN0    = 0x9C;                   // Receive enable
 186      =1  sbit TB80    = 0x9B;                   // Transmit bit 8
 187      =1  sbit RB80    = 0x9A;                   // Receive bit 8
 188      =1  sbit TI0     = 0x99;                   // Transmit interrupt flag
 189      =1  sbit RI0     = 0x98;                   // Receive interrupt flag
 190      =1  
 191      =1  // IE 0xA8
 192      =1  sbit EA      = 0xAF;                   // Global interrupt enable
 193      =1  sbit ESPI0   = 0xAE;                   // SPI0 interrupt enable
 194      =1  sbit ET2     = 0xAD;                   // Timer2 interrupt enable
 195      =1  sbit ES0     = 0xAC;                   // UART0 interrupt enable
 196      =1  sbit ET1     = 0xAB;                   // Timer1 interrupt enable
 197      =1  sbit EX1     = 0xAA;                   // External interrupt 1 enable
 198      =1  sbit ET0     = 0xA9;                   // Timer0 interrupt enable
 199      =1  sbit EX0     = 0xA8;                   // External interrupt 0 enable
 200      =1  
 201      =1  // IP 0xB8
 202      =1                                         // Bit7 UNUSED
 203      =1  sbit PSPI0   = 0xBE;                   // SPI0 interrupt priority
 204      =1  sbit PT2     = 0xBD;                   // Timer2 priority
 205      =1  sbit PS0     = 0xBC;                   // UART0 priority
 206      =1  sbit PT1     = 0xBB;                   // Timer1 priority
 207      =1  sbit PX1     = 0xBA;                   // External interrupt 1 priority
 208      =1  sbit PT0     = 0xB9;                   // Timer0 priority
 209      =1  sbit PX0     = 0xB8;                   // External interrupt 0 priority
 210      =1  
 211      =1  // SMB0CN 0xC0
 212      =1  sbit MASTER  = 0xC7;                   // Master/slave indicator
 213      =1  sbit TXMODE  = 0xC6;                   // Transmit mode indicator
 214      =1  sbit STA     = 0xC5;                   // Start flag
 215      =1  sbit STO     = 0xC4;                   // Stop flag
 216      =1  sbit ACKRQ   = 0xC3;                   // Acknowledge request
 217      =1  sbit ARBLOST = 0xC2;                   // Arbitration lost indicator
 218      =1  sbit ACK     = 0xC1;                   // Acknowledge flag
 219      =1  sbit SI      = 0xC0;                   // SMBus interrupt flag
 220      =1  
 221      =1  // TMR2CN 0xC8
 222      =1  sbit TF2H    = 0xCF;                   // Timer2 high byte overflow flag
 223      =1  sbit TF2L    = 0xCE;                   // Timer2 low byte overflow flag
 224      =1  sbit TF2LEN  = 0xCD;                   // Timer2 low byte interrupt enable
 225      =1  sbit T2SOF   = 0xCC;                   // Timer2 start-of-frame capture enable
 226      =1  sbit T2SPLIT = 0xCB;                   // Timer2 split mode enable
 227      =1  sbit TR2     = 0xCA;                   // Timer2 on/off control
 228      =1                                         // Bit1 UNUSED
 229      =1  sbit T2XCLK  = 0xC8;                   // Timer2 external clock select
 230      =1  
 231      =1  // PSW 0xD0
 232      =1  sbit CY      = 0xD7;                   // Carry flag
 233      =1  sbit AC      = 0xD6;                   // Auxiliary carry flag
 234      =1  sbit F0      = 0xD5;                   // User flag 0
 235      =1  sbit RS1     = 0xD4;                   // Register bank select 1
 236      =1  sbit RS0     = 0xD3;                   // Register bank select 0
 237      =1  sbit OV      = 0xD2;                   // Overflow flag
 238      =1  sbit F1      = 0xD1;                   // User flag 1
 239      =1  sbit P       = 0xD0;                   // Accumulator parity flag
 240      =1  
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 5   

 241      =1  // PCA0CN 0xD8
 242      =1  sbit CF      = 0xDF;                   // PCA0 counter overflow flag
 243      =1  sbit CR      = 0xDE;                   // PCA0 counter run control
 244      =1                                         // Bit5 UNUSED
 245      =1  sbit CCF4    = 0xDC;                   // PCA0 module4 capture/compare flag
 246      =1  sbit CCF3    = 0xDB;                   // PCA0 module3 capture/compare flag
 247      =1  sbit CCF2    = 0xDA;                   // PCA0 module2 capture/compare flag
 248      =1  sbit CCF1    = 0xD9;                   // PCA0 module1 capture/compare flag
 249      =1  sbit CCF0    = 0xD8;                   // PCA0 module0 capture/compare flag
 250      =1  
 251      =1  // ADC0CN 0xE8
 252      =1  sbit AD0EN   = 0xEF;                   // ADC0 enable
 253      =1  sbit AD0TM   = 0xEE;                   // ADC0 track mode
 254      =1  sbit AD0INT  = 0xED;                   // ADC0 converision complete interrupt flag
 255      =1  sbit AD0BUSY = 0xEC;                   // ADC0 busy flag
 256      =1  sbit AD0WINT = 0xEB;                   // ADC0 window compare interrupt flag
 257      =1  sbit AD0CM2  = 0xEA;                   // ADC0 conversion mode select 2
 258      =1  sbit AD0CM1  = 0xE9;                   // ADC0 conversion mode select 1
 259      =1  sbit AD0CM0  = 0xE8;                   // ADC0 conversion mode select 0
 260      =1  
 261      =1  // SPI0CN 0xF8
 262      =1  sbit SPIF    = 0xFF;                   // SPI0 interrupt flag
 263      =1  sbit WCOL    = 0xFE;                   // SPI0 write collision flag
 264      =1  sbit MODF    = 0xFD;                   // SPI0 mode fault flag
 265      =1  sbit RXOVRN  = 0xFC;                   // SPI0 rx overrun flag
 266      =1  sbit NSSMD1  = 0xFB;                   // SPI0 slave select mode 1
 267      =1  sbit NSSMD0  = 0xFA;                   // SPI0 slave select mode 0
 268      =1  sbit TXBMT   = 0xF9;                   // SPI0 transmit buffer empty
 269      =1  sbit SPIEN   = 0xF8;                   // SPI0 SPI enable
 270      =1  
 271      =1  
 272      =1  //-----------------------------------------------------------------------------
 273      =1  // Interrupt Priorities
 274      =1  //-----------------------------------------------------------------------------
 275      =1  
 276      =1  #define INTERRUPT_INT0             0   // External Interrupt 0
 277      =1  #define INTERRUPT_TIMER0           1   // Timer0 Overflow
 278      =1  #define INTERRUPT_INT1             2   // External Interrupt 1
 279      =1  #define INTERRUPT_TIMER1           3   // Timer1 Overflow
 280      =1  #define INTERRUPT_UART0            4   // Serial Port 0
 281      =1  #define INTERRUPT_TIMER2           5   // Timer2 Overflow
 282      =1  #define INTERRUPT_SPI0             6   // Serial Peripheral Interface 0
 283      =1  #define INTERRUPT_SMBUS0           7   // SMBus0 Interface
 284      =1  #define INTERRUPT_USB0             8   // USB Interface
 285      =1  #define INTERRUPT_ADC0_WINDOW      9   // ADC0 Window Comparison
 286      =1  #define INTERRUPT_ADC0_EOC         10  // ADC0 End Of Conversion
 287      =1  #define INTERRUPT_PCA0             11  // PCA0 Peripheral
 288      =1  #define INTERRUPT_COMPARATOR0      12  // Comparator0
 289      =1  #define INTERRUPT_COMPARATOR1      13  // Comparator1
 290      =1  #define INTERRUPT_TIMER3           14  // Timer3 Overflow
 291      =1  #define INTERRUPT_VBUS_LEVEL       15  // VBUS level-triggered interrupt
 292      =1  #define INTERRUPT_UART1            16  // Serial Port 1
 293      =1  
 294      =1  //-----------------------------------------------------------------------------
 295      =1  // Header File PreProcessor Directive
 296      =1  //-----------------------------------------------------------------------------
 297      =1  
 298      =1  // #endif                                 
 299      =1  
 300      =1  // #define C8051F340_H
 301      =1  
 302      =1  //Fim do header original. Modificações e extensões abaixo.
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 6   

 303      =1  
 304      =1  /*  8052 Extensions  */
 305      =1  sfr T2CON  = 0xC8;
 306      =1  sfr T2MOD  = 0xC9;
 307      =1  sfr RCAP2L = 0xCA;
 308      =1  sfr RCAP2H = 0xCB;
 309      =1  sfr TL2    = 0xCC;
 310      =1  sfr TH2    = 0xCD;
 311      =1  
 312      =1  /* PORT 0 - Adicionada por Douglas Melchioretto */ 
 313      =1  sbit P0_0  = P0^0;
 314      =1  sbit P0_1  = P0^1;
 315      =1  sbit P0_2  = P0^2;
 316      =1  sbit P0_3  = P0^3;
 317      =1  sbit P0_4  = P0^4;
 318      =1  sbit P0_5  = P0^5;
 319      =1  sbit P0_6  = P0^6;
 320      =1  sbit P0_7  = P0^7;
 321      =1  
 322      =1  /* PORT 1 - Adicionada por Douglas Melchioretto */
 323      =1  sbit P1_0  = P1^0;
 324      =1  sbit P1_1  = P1^1;
 325      =1  sbit P1_2  = P1^2;
 326      =1  sbit P1_3  = P1^3;
 327      =1  sbit P1_4  = P1^4;
 328      =1  sbit P1_5  = P1^5;
 329      =1  sbit P1_6  = P1^6;
 330      =1  sbit P1_7  = P1^7;
 331      =1  
 332      =1  /* PORT 2 - Adicionada por Douglas Melchioretto */
 333      =1  sbit P2_0  = P2^0;
 334      =1  sbit P2_1  = P2^1;
 335      =1  sbit P2_2  = P2^2;
 336      =1  sbit P2_3  = P2^3;
 337      =1  sbit P2_4  = P2^4;
 338      =1  sbit P2_5  = P2^5;
 339      =1  sbit P2_6  = P2^6;
 340      =1  sbit P2_7  = P2^7;
 341      =1  
 342      =1  
 343      =1  
 344      =1  /*  SCON  */
 345      =1  sbit SM0   = SCON0^7;
 346      =1  sbit SM1   = SCON0^6;
 347      =1  sbit SM2   = SCON0^5;
 348      =1  sbit REN   = SCON0^4;
 349      =1  sbit TB8   = SCON0^3;
 350      =1  sbit RB8   = SCON0^2;
 351      =1  sbit TI    = SCON0^1;
 352      =1  sbit RI    = SCON0^0;
 353      =1  
 354      =1  /*  P1  */
 355      =1  sbit T2EX  = P1^1; // 8052 only
 356      =1  sbit T2    = P1^0; // 8052 only
 357      =1               
 358      =1  /*  T2CON  */
 359      =1  sbit TF2    = T2CON^7;
 360      =1  sbit EXF2   = T2CON^6;
 361      =1  sbit RCLK   = T2CON^5;
 362      =1  sbit TCLK   = T2CON^4;
 363      =1  sbit EXEN2  = T2CON^3;
 364      =1  sbit C_T2   = T2CON^1;
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 7   

 365      =1  sbit CP_RL2 = T2CON^0;
 366      =1  
 367      =1  #endif
   2          //#include <stdio.h>                  /* define I/O functions  */
   3          #include "protocolo.h"                          /* arquivo de definicoes de constantes */
   1      =1  /*************************
   2      =1  * Arquivo: protocolo.h
   3      =1  * Descricao: contem a definicao dos comandos que sao
   4      =1  * enviados/recebidos pelo robo
   5      =1  **************************/
   6      =1  
   7      =1  #define ON                                      0x01
   8      =1  #define OFF                                     0x00
   9      =1  
  10      =1  // Encoder (encoder indice 0 -> 0x20, encoder 1 -> 0x21)
  11      =1  #define ENCODER                         0x20            
  12      =1  
  13      =1  // Sensores de distancia
  14      =1  #define OPTICAL_SENSOR_0                0x22
  15      =1  #define OPTICAL_SENSOR_1                0x23
  16      =1  #define OPTICAL_SENSOR_2                0x24
  17      =1  #define OPTICAL_SENSOR_3                0x25
  18      =1  #define OPTICAL_SENSOR_4                0x26
  19      =1  #define OPTICAL_SENSOR_5                0x27
  20      =1  
  21      =1  // Comandos para controlar PWM
  22      =1  #define LEFT_WHEEL                      0xA0 // Nivel das PWMS de Movimentacao ou passos
  23      =1  #define RIGHT_WHEEL                     0xA1 // Nivel das PWMS de Movimentacao ou passos
  24      =1  
  25      =1  // Comando para sincronizacao
  26      =1  #define SYNC                            0xB0
  27      =1  
  28      =1  // Comando para fazer o robo parar imediatamente
  29      =1  #define STOP                            0xFF // Parada De Emergencia !!!!
  30      =1  
  31      =1  #define RESET                           0xF0 // Ordem para RESET GLOBAL
  32      =1  
  33      =1  // Byte que sinaliza fim do comando
  34      =1  #define END_CMD                         0xFE
  35      =1  
  36      =1  // Mascara para obter o valor do pwm e o sentido
  37      =1  // o bit mais significativo representa o sentido,
  38      =1  // enquanto os restantes representam o valor de PWM
  39      =1  #define PWM_DIR                         0x80  // Mascara que define o bit de sentido da PWM
  40      =1  #define PWM_MASK                        0x7F  // Mascara que define o bit de valor   da PWM
  41      =1  
  42      =1  // Resposta caso a mensagem recebida nao seja identificada
  43      =1  #define ERRO                            0x45
   4          
   5          
   6          //#define DEBUG                                 // SE COMENTAR ESSE DEFINE, GERA O CODIGO SEM AS MENSAGEMS DE DEBUG !!!
   7          #define PWM_RIGHT_FORWARD P1_0  // DEFINE O PINO NO QUE GERA A PWM PARA A RODA DIREITA GIRAR PARA FRENTE
   8          #define PWM_RIGHT_REVERSE P1_2  // DEFINE O PINO NO QUE GERA A PWM PARA A RODA DIREITA GIRAR PARA TRAS
   9          #define PWM_LEFT_FORWARD  P1_4  // DEFINE O PINO NO QUE GERA A PWM PARA A RODA ESQUERA GIRAR PARA FRENTE
  10          #define PWM_LEFT_REVERSE  P1_6  // DEFINE O PINO NO QUE GERA A PWM PARA A RODA ESQUERA GIRAR PARA TRAS
  11          
  12          #define TERRA   0x1F
  13          #define VCC     0x1F
  14          #define CHANNEL_0 0x00          // DIRECIONA A LEITURA DO CHANNEL 0 PARA o PINO P2.0
  15          #define CHANNEL_1 0x01          // DIRECIONA A LEITURA DO CHANNEL 1 PARA o PINO P2.1
  16          #define CHANNEL_2 0x02          // DIRECIONA A LEITURA DO CHANNEL 2 PARA o PINO P2.2
  17          #define CHANNEL_3 0x03          // DIRECIONA A LEITURA DO CHANNEL 3 PARA o PINO P2.3
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 8   

  18          #define CHANNEL_4 0x04          // DIRECIONA A LEITURA DO CHANNEL 4 PARA o PINO P2.5 
  19          #define CHANNEL_5 0x05          // DIRECIONA A LEITURA DO CHANNEL 5 PARA o PINO P2.6
  20          
  21          #define SYSCLK       48000000   // SYSCLK frequency in Hz
  22          #define BAUDRATE0      115200   // Baud rate of UART0 in bps
  23          #define BAUDRATE1      115200   // Baud rate of UART1 in bps
  24          sfr16   SBRL1 = 0xB4;
  25          
  26          #define VELOCITY_STEP 5 // DEFINE O PASSO DE VELOCIDADE. PODE SER DIMINUIDO PARA OBTER MAIS NIVEIS
  27          #define TMAX 75                 // PWMS com duty cycle de 75 overflows do timer0
  28          
  29          unsigned int pwm_right=0;       // PWM RODA DIREITA
  30          unsigned int pwm_left=0;        // PWM RODA ESQUERDA
  31          
  32          unsigned char sensorCount = 0;  // Marca qual sensor acabou de ter sua leitura convertida.
  33          unsigned char sensor_values[6]; // Armazena as conversoes mais recentes.
  34          bit new_conversion_flag=0;      // Indica que ocorreu uma varredura completa dos sensores.
  35          bit new_cmd_flag=0;     // Indica que foi recebido um novo command.
  36          unsigned int timer3count = 0;   // Contador para gerar delay no Timer 3.
  37          
  38          unsigned char Rx_Buff;
  39          unsigned char Tx_Buff;
  40          
  41          bit sentido;                                    // SENTIDO GERAL DO ROBO... TALVEZ NAO SEJA MAIS NECESSARIA LOGO...
  42          
  43          bit flag_send = 0;
  44          bit left_wheel_dir=1;   // DEFINE O SENTIDO DE ROTACAO DA RODA ESQUERA - MUDA NA EXECUCAO DO SOFTWARE
  45          bit right_wheel_dir=1;          // DEFINE O SENTIDO DE ROTACAO DA RODA DIREITA - MUDA NA EXECUCAO DO SOFTWARE
  46          char rec_command[8];                            // RECEBE O command PELA PORTA SERIAL PELO HIPER-TERMINAL...
  47                                                                          // PROVAMENTE SERA MODIFICADO PARA UM VETOR DE CHAR QUANDO DE DESEJAR 
  48                                                                          // OBTER DADOS DO ROBO OU COMANDOS DE MOVIMENTACAO MAIS COMPLEXOS...
  49          
  50          unsigned char i;                                // INDICE AUXILIAR PARA LOOPS
  51          
  52          
  53          bit UART = 0;
  54          
  55          unsigned int encoder_count[2] = {0, 0};
  56          
  57          
  58          char putchar (char c)  {
  59   1      
  60   1         if (UART == 0) {
  61   2      
  62   2            if (c == '\n')  {                // check for newline character
  63   3               while (!flag_send);    // wait until UART0 is ready to transmit
  64   3               flag_send = 0;         // clear interrupt flag
  65   3               SBUF0 = 0x0d;                 // output carriage return command
  66   3            }
  67   2            while (!flag_send);                    // wait until UART0 is ready to transmit
  68   2            flag_send = 0;                         // clear interrupt flag
  69   2            return (SBUF0 = c);              // output <c> using UART 0
  70   2         }
  71   1      
  72   1         else if (UART == 1) {
  73   2            if (c == '\n')  {                // check for newline character
  74   3               while (!(SCON1 & 0x02));      // wait until UART1 is ready to transmit
  75   3               SCON1 &= ~0x02;               // clear TI1 interrupt flag
  76   3               SBUF1 = 0x0d;                 // output carriage return
  77   3            }
  78   2            while (!(SCON1 & 0x02));         // wait until UART1 is ready to transmit
  79   2            SCON1 &= ~0x02;                  // clear TI1 interrupt flag
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 9   

  80   2            return (SBUF1 = c);              // output <c> using UART 1
  81   2         }
  82   1      }
  83          
  84          void pwm_setup(){
  85   1          // 0000 0011
  86   1              TMOD = (TMOD | 0x03);   // Programa o Timer0 para para Operacao em modo 3, como 2 timers de 8
  87   1                                                              // bits cada. [ TCOM.M0=1 ] [ TCOM.M1=1 ]
  88   1                                                              // operando na forma de Timer ( Counter(1) / Timer(0) = 0) [ TCOM.C/T ]
  89   1                                                              // controlados por software  ( GATE=0 )
  90   1              ET0 = 1;                                // Enable or disable the Timer 0 overflow interrupt.
  91   1              ET1 = 0;                                // Disable the Timer 1 overflow interrupt. Agora controlando o timer0 "TL0"
  92   1              TR0 = 1;                                // Ativa Timer 0 No registro controlador do Timer
  93   1              TR1 = 0;                                // Desativa Timer 1 No registro controlador do Timer.Agora controlando o timer0 "TL0"
  94   1              EA = 1;                 // Ativa Todas as Interrupcoes
  95   1      }
  96          
  97          
  98          void Delay(void)
  99          {
 100   1         int x;
 101   1         for(x = 0;x < 500;x)
 102   1            x++;
 103   1      }
 104          
 105          void SYSTEMCLOCK_Init (void)                    //Retirado do exemplo de Comunica??o UART do Kit da SLI LABS
 106                                                                                          //C8051F340
 107          {
 108   1         OSCICN |= 0x03;                     // Configure internal oscillator for
 109   1                                             // its maximum frequency and enable
 110   1                                             // missing clock detector
 111   1      
 112   1         CLKMUL  = 0x00;                     // Select internal oscillator as
 113   1                                             // input to clock multiplier
 114   1      
 115   1         CLKMUL |= 0x80;                     // Enable clock multiplier
 116   1         Delay();                            // Delay for clock multiplier to begin
 117   1         CLKMUL |= 0xC0;                     // Initialize the clock multiplier
 118   1         Delay();                            // Delay for clock multiplier to begin
 119   1      
 120   1         while(!(CLKMUL & 0x20));            // Wait for multiplier to lock
 121   1         CLKSEL  = 0x03;                     // Select system clock
 122   1      }
 123          
 124          void PORT_Init (void)                                   //Retirado do exemplo de comunica??o UART do Kit
 125          {  
 126   1         XBR0 = 0x01;                        // route UART 0 to crossbar
 127   1         XBR2 = 0x01;                                                 // route UART 1 to crossbar
 128   1         XBR1 = 0x40;                                                 // enable crossbar
 129   1         P0MDIN  = 0xFF;                                              // Port P0 = entrada digital
 130   1         P0MDOUT = 0x00;                     // Port P0 = saida OpenDrain
 131   1         P1MDOUT = 0x00;                                         // Mantem todas os pinos do Port 1 em OpenDrain (0) ou PushPull (1)
 132   1         P1MDIN  = 0xFF;                                         // Mantem todas os pinos do Port 1 como entradas Digitais
 133   1         P2MDOUT |= 0x04;                    // set LED to push-pull
 134   1      }
 135          
 136          void serial_setup(){
 137   1      
 138   1         // 0001 0000
 139   1         SCON0 = 0x10;                       // SCON0: 8-bit variable bit rate
 140   1                                             //        level of STOP bit is ignored
 141   1                                             //        RX enabled
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 10  

 142   1                                             //        ninth bits are zeros
 143   1                                             //        clear RI0 and TI0 bits
 144   1      
 145   1              // UartBaudRate =  T1 CLK / ( 256 - T1H ) * 0.5
 146   1      
 147   1         if (SYSCLK/BAUDRATE0/2/256 < 1) {
 148   2            TH1 = -(SYSCLK/BAUDRATE0/2);
 149   2            CKCON &= ~0x0B;                  // T1M = 1; SCA1:0 = xx
 150   2            CKCON |=  0x08;
 151   2         } else if (SYSCLK/BAUDRATE0/2/256 < 4) {
 152   2            TH1 = -(SYSCLK/BAUDRATE0/2/4);
 153   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 01                 
 154   2            CKCON |=  0x09;
 155   2         } else if (SYSCLK/BAUDRATE0/2/256 < 12) {
 156   2            TH1 = -(SYSCLK/BAUDRATE0/2/12);
 157   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 00
 158   2         } else {
 159   2            TH1 = -(SYSCLK/BAUDRATE0/2/48);
 160   2            CKCON &= ~0x0B;                  // T1M = 0; SCA1:0 = 10
 161   2            CKCON |=  0x02;
 162   2         }
 163   1      
 164   1         TL1 = TH1;      // init Timer1
 165   1         // 0000 1111 - apaga os 4 primeiros bits
 166   1         TMOD &= ~0xf0;  // TMOD: timer 1 in 8-bit autoreload
 167   1         // seta 0010 0000
 168   1         TMOD |=  0x20;                       
 169   1         TR1 = 1;        // START Timer1
 170   1         TI0 = 1;        // Indicate TX0 ready
 171   1         ES0 = 1;
 172   1      }
 173          
 174          void encoder_setup(){   
 175   1              IT01CF = 0x31;  // INT0 e INT1 ativo alto, P0.1 = INT0, P0.3 = INT1
 176   1              IT0 = 0;                // Edge sensitive INT0
 177   1              IT1 = 0;                // Edge sensitive INT1
 178   1              IE0 = 0;                // Apaga flag interrupcao INT0
 179   1              IE1 = 0;                // Apaga flag interrupcao INT1  
 180   1              EX0 = 1;                // Habilita INT0 (interrupcao externa)
 181   1              EX1 = 1;                // Habilita INT1 (interrupcao externa)
 182   1      
 183   1      }
 184                          
 185          void ativa_direita(void){
 186   1              if (right_wheel_dir) {          // Avalia sentido da roda direita (em frente == 1)
 187   2                      PWM_RIGHT_REVERSE = OFF;        // Desliga o PWM para tras
 188   2                      PWM_RIGHT_FORWARD = ON;         // Liga o PWM para frente
 189   2              }
 190   1              else {
 191   2                      PWM_RIGHT_FORWARD = OFF;        // Desliga o PWM para frente
 192   2                      PWM_RIGHT_REVERSE = ON;         // Liga o PWM para tras
 193   2              }
 194   1      }
 195          
 196          void desativa_direita(void){
 197   1              PWM_RIGHT_REVERSE = OFF;                // Desliga o PWM para tras
 198   1              PWM_RIGHT_FORWARD = OFF;                // Desliga o PWM para frente
 199   1      }
 200          
 201          void ativa_esquerda(void){
 202   1              if (left_wheel_dir) {    // Avalia sentido da roda direita (em frente == 1)
 203   2                      PWM_LEFT_REVERSE = OFF;         // Desliga o PWM para tras
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 11  

 204   2                      PWM_LEFT_FORWARD = ON;          // Liga o PWM para frente
 205   2              }
 206   1              else {
 207   2                      PWM_LEFT_FORWARD = OFF;         // Desliga o PWM para frente
 208   2                      PWM_LEFT_REVERSE = ON;          // Liga o PWM para tras
 209   2              }
 210   1      }
 211          
 212          void desativa_esquerda(void){
 213   1              PWM_LEFT_REVERSE = OFF;         // Desliga o PWM para tras
 214   1              PWM_LEFT_FORWARD = OFF;         // Desliga o PWM para frente
 215   1      }
 216          
 217          // Versao Nova - Usado no Micro 8051F340 (48Mhz)
 218          void timer0_IT() interrupt 1 {
 219   1              static unsigned int pwm_aux=TMAX;
 220   1              static unsigned int pwm_left_temp=0;
 221   1              static unsigned int pwm_right_temp=0;
 222   1      
 223   1              TR0 = OFF;                                                      // Desliga o Timer 0 - Obrigatorio, pois precisamos 
 224   1                                                                                      // setar os valores do timer a cada vez que este este 
 225   1                                                                                      // estra na rotina de tratamento da interrupcao,ora com 
 226   1                                                                                      // valores maiores ora com valores menores.
 227   1      
 228   1              pwm_aux++;  // Incrementa contador de overflows
 229   1              if ( pwm_aux == TMAX ) {
 230   2                      // Fim de Ciclo de Geracao da PWM ( 251 Hz )
 231   2                      pwm_left_temp=pwm_left;   // Recarega com valores de pwm
 232   2                      pwm_right_temp=pwm_right; // Recarega com valores de pwm
 233   2                      pwm_aux=0;                                // Reseta contador
 234   2              }
 235   1              else {
 236   2                      if (pwm_left_temp>0) { 
 237   3                              ativa_esquerda(); 
 238   3                      } 
 239   2                      else { 
 240   3                              desativa_esquerda();
 241   3                      }
 242   2                      if (pwm_right_temp>0) {
 243   3                              ativa_direita();
 244   3                      }
 245   2                      else { 
 246   3                              desativa_direita();
 247   3                      }
 248   2                      if (pwm_left_temp >0) pwm_left_temp--; 
 249   2                      if (pwm_right_temp>0) pwm_right_temp--; 
 250   2              }
 251   1      
 252   1              TL0=0;      // Zera Timer
 253   1              TF0 = 0;        // Limpa Flag de Interrupcao do Timer 0    
 254   1              TR0 = 1;        // Ligar o Timer 0
 255   1      }
 256          
 257          void ADC_setup () {     // USAR TIMER 3
 258   1              REF0CN = 0x08;          // Seleciona VDD como tensao de referencia.
 259   1              AMX0N = TERRA;          // Define a entrada negativa do ADC0 como GND.
 260   1              ADC0CF = 11<<3;         // Configura o CLOCK do passo da conversao como 4.8MHZ
 261   1              ADC0CF |= 0x04;         // Configura o ADC0 para ignorar os 2 bits menos
 262   1                                                      // significativos da conversao
 263   1              AMX0P = CHANNEL_0;      // Seleciona a entrada da conversao como o canal 0 (P2.0)
 264   1          TMR3CN &= ~0x01;
 265   1              CKCON &= 0x3F;
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 12  

 266   1              TMR3L = 0xFF;           // Configura o valor maximo da contagem como 255
 267   1              TMR3RLL = 0;
 268   1              EIE1 |= 0x88;
 269   1              TMR3CN = 0x28;          // Habilita interrupcao do timer 3 pelo low byte.
 270   1              ADC0CN = 0x80;          // Seleciona inicio de conversao no set do bit ADCBUSY.
 271   1      }
 272          
 273          void interrupt_timer3() interrupt 14 {  // Trata a interrupcao do Timer 3
 274   1      
 275   1              // 784 - 50 ms
 276   1              // 3136 - 200 ms
 277   1              if(timer3count == 3136 * 5) { // Contar para gerar um delay de 200ms
 278   2                      AD0BUSY =1;                               // Iniciar as conversoes no ADC0.
 279   2                      timer3count = 0;
 280   2              }
 281   1              else timer3count++;
 282   1              TMR3CN &= ~0x40;
 283   1      }
 284          
 285          void interrupt_ADC() interrupt 10 { // Tratamento da interrupcao do ADC0
 286   1              switch(sensorCount){
 287   2                      case 0:
 288   2                              AMX0P =  CHANNEL_1;     // Seleciona a entrada da conversao como o canal 1 (P2.1)
 289   2                      break;
 290   2                      case 1:
 291   2                              AMX0P =  CHANNEL_2;     // Seleciona a entrada da conversao como o canal 2 (P2.2)
 292   2                      break;
 293   2                      case 2:
 294   2                              AMX0P =  CHANNEL_3;     // Seleciona a entrada da conversao como o canal 3 (P2.3)
 295   2                      break;
 296   2                      case 3:
 297   2                              AMX0P =  CHANNEL_4;     // Seleciona a entrada da conversao como o canal 4 (P2.5)
 298   2                      break;
 299   2                      case 4:
 300   2                              AMX0P =  CHANNEL_5;     // Seleciona a entrada da conversao como o canal 5 (P2.6)
 301   2                      break;
 302   2                      case 5:
 303   2                              AMX0P =  CHANNEL_0;     // Seleciona a entrada da conversao como o canal 0 (P2.0)
 304   2                              new_conversion_flag = 1;
 305   2                      break;
 306   2              }
 307   1              sensor_values[sensorCount] = ADC0H;
 308   1              if(sensorCount == 5) { 
 309   2                      sensorCount = 0xFF; // Sinaliza que nao havera mais conversoes
 310   2              }
 311   1              sensorCount++;
 312   1              if(sensorCount != 0) AD0BUSY = 1; // Dispara a proxima conversao.
 313   1              AD0INT = 0;
 314   1      }
 315          
 316          void send_distances_info() {
 317   1      
 318   1              unsigned char command[4];
 319   1              unsigned char indice;
 320   1              unsigned char indice2;
 321   1              for(indice = 0; indice < 6; indice++){
 322   2                      command[0] = OPTICAL_SENSOR_0 + indice;
 323   2                      command[1] = sensor_values[indice] + (sensor_values[indice] == 0);
 324   2                      command[2] = END_CMD;
 325   2                      command[3] = '\n';
 326   2                      for(indice2 = 0; indice2 < 4 ; indice2++) {             
 327   3                              while(!flag_send);
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 13  

 328   3                              flag_send = 0;
 329   3                              SBUF0 = command[indice2];
 330   3                      }
 331   2              }
 332   1      }
 333          
 334          void send_encoders_info() {
 335   1      
 336   1              unsigned char command[5];
 337   1              unsigned char indice, iencoder;
 338   1              for(iencoder = 0; iencoder < 2; ++iencoder){
 339   2                      command[0] = ENCODER + iencoder;
 340   2                      command[1] = encoder_count[iencoder] >> 8;
 341   2                      command[2] = encoder_count[iencoder] & 0xFF;
 342   2                      command[3] = END_CMD;
 343   2                      command[4] = '\n';
 344   2                      for(indice = 0; indice < 5 ; indice++) {                
 345   3                              while(!flag_send);
 346   3                              flag_send = 0;
 347   3                              SBUF0 = command[indice];
 348   3                      }
 349   2              }
 350   1      }
 351          
 352          
 353          void interrupt_encoder_right() interrupt 0 {
 354   1              //PORT0.1
 355   1              ++encoder_count[0];
 356   1              IE0 = 0;
 357   1      }
 358          
 359          void interrupt_encoder_left() interrupt 2 {
 360   1              //PORT0.3
 361   1              ++encoder_count[1];
 362   1              IE1 = 0;
 363   1      }
 364          
 365          void interrupt_serial() interrupt 4 { // Tratamento da interrupcao da UART0
 366   1              static short int indice = 0;
 367   1              if (RI0 == 1){                                  
 368   2                      rec_command[indice] = SBUF0;
 369   2                      if(rec_command[indice] == '\n' || indice ==5) { // Limitando rec_command em 6 caracteres
 370   3                              rec_command[indice] = '\0';
 371   3                              indice = 0;
 372   3                              new_cmd_flag = 1;
 373   3                      }       
 374   2                      else indice++;
 375   2                      RI0=0;
 376   2              }
 377   1      
 378   1              if(TI0 == 1) {
 379   2                      TI0 = 0;
 380   2                      flag_send = 1;
 381   2              }
 382   1      
 383   1      }
 384          void main (void)  {     /* main program */
 385   1      
 386   1          PCA0MD &= ~0x40;    // Disable Watchdog timer
 387   1      
 388   1              SYSTEMCLOCK_Init(); // Inicializa??o do Clock da Serial
 389   1              PORT_Init();            
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 14  

 390   1      
 391   1              serial_setup();         // Configura a comunicacao serial
 392   1              pwm_setup();            // Configura o PWM
 393   1              encoder_setup();        // Configura o encoder
 394   1      
 395   1              ADC_setup();            // Configura o ADC0
 396   1              EA = 1;                         // Habilita todas as interrupcoes
 397   1      
 398   1      //      pwm_left  = 35;         // hardcode - teste da PWM
 399   1      //      pwm_right = 35;         // hardcode - teste da PWM
 400   1              left_wheel_dir = 0;
 401   1              right_wheel_dir = 0;
 402   1      
 403   1        while (1)  { // Loop infinito....
 404   2                /*
 405   2              if(new_conversion_flag){        // Novos valores de conversao disponiveis
 406   2                      //send_distances_info();
 407   2                      new_conversion_flag = 0;
 408   2      //              for (i=0; i<6; i++) {
 409   2      //                      old_values[i] = sensor_values[i]; // Armazena valores velhos
 410   2      //              }
 411   2              }
 412   2              */
 413   2              if(new_cmd_flag){
 414   3      
 415   3      #ifdef DEBUG
                          printf("Received command: %c %c %c %c -",rec_command[0],rec_command[1],rec_command[2],rec_command[3])
             -;
              #endif
 418   3                      new_cmd_flag = 0;
 419   3                      switch (rec_command[0]) {
 420   4                              case LEFT_WHEEL:
 421   4                                      #ifdef DEBUG
                                                      printf("LEFT_WHEEL\n");
                                              #endif
 424   4                                      left_wheel_dir = (rec_command[1] & PWM_DIR);
 425   4                                      pwm_left = (rec_command[1] & PWM_MASK) * VELOCITY_STEP;
 426   4                                      break;
 427   4                              case RIGHT_WHEEL:
 428   4                                      #ifdef DEBUG
                                                      printf("RIGHT_WHEEL\n");
                                              #endif
 431   4                                      right_wheel_dir=(rec_command[1] & PWM_DIR);
 432   4                                      pwm_right = (rec_command[1] & PWM_MASK) * VELOCITY_STEP;
 433   4                                      break;
 434   4                      
 435   4                              case STOP: 
 436   4                                      pwm_right=pwm_left=0;
 437   4                                      #ifdef DEBUG
                                                      printf("STOP ! \n");
                                              #endif
 440   4                                      break;
 441   4                              case SYNC:
 442   4                                      send_distances_info();
 443   4                                      send_encoders_info();
 444   4                                      break;
 445   4                      
 446   4                              default:
 447   4                                      //SBUF0 = ERRO;
 448   4                              break;
 449   4                      } 
 450   3              }
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 15  

 451   2       }
 452   1      }
 453          
 454          
*** WARNING C291 IN LINE 82 OF MAIN.C: not every exit path returns a value
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 16  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _putchar (BEGIN)
                                           ; SOURCE LINE # 58
;---- Variable 'c' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 60
0000 200014      R     JB      UART,?C0001
                                           ; SOURCE LINE # 62
0003 EF                MOV     A,R7
0004 B40A08            CJNE    A,#0AH,?C0005
0007         ?C0003:
                                           ; SOURCE LINE # 63
0007 3000FD      R     JNB     flag_send,?C0003
000A         ?C0004:
                                           ; SOURCE LINE # 64
000A C200        R     CLR     flag_send
                                           ; SOURCE LINE # 65
000C 75990D            MOV     SBUF0,#0DH
                                           ; SOURCE LINE # 66
000F         ?C0005:
                                           ; SOURCE LINE # 67
000F 3000FD      R     JNB     flag_send,?C0005
0012         ?C0006:
                                           ; SOURCE LINE # 68
0012 C200        R     CLR     flag_send
                                           ; SOURCE LINE # 69
0014 8F99              MOV     SBUF0,R7
0016 22                RET     
                                           ; SOURCE LINE # 70
0017         ?C0001:
                                           ; SOURCE LINE # 72
0017 300019      R     JNB     UART,?C0007
                                           ; SOURCE LINE # 73
001A EF                MOV     A,R7
001B B40A0B            CJNE    A,#0AH,?C0013
001E         ?C0011:
                                           ; SOURCE LINE # 74
001E E5D2              MOV     A,SCON1
0020 30E1FB            JNB     ACC.1,?C0011
0023         ?C0012:
                                           ; SOURCE LINE # 75
0023 53D2FD            ANL     SCON1,#0FDH
                                           ; SOURCE LINE # 76
0026 75D30D            MOV     SBUF1,#0DH
                                           ; SOURCE LINE # 77
0029         ?C0013:
                                           ; SOURCE LINE # 78
0029 E5D2              MOV     A,SCON1
002B 30E1FB            JNB     ACC.1,?C0013
002E         ?C0014:
                                           ; SOURCE LINE # 79
002E 53D2FD            ANL     SCON1,#0FDH
                                           ; SOURCE LINE # 80
0031 8FD3              MOV     SBUF1,R7
                                           ; SOURCE LINE # 81
                                           ; SOURCE LINE # 82
0033         ?C0007:
0033 22                RET     
             ; FUNCTION _putchar (END)

             ; FUNCTION pwm_setup (BEGIN)
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 17  

                                           ; SOURCE LINE # 84
                                           ; SOURCE LINE # 86
0000 438903            ORL     TMOD,#03H
                                           ; SOURCE LINE # 90
0003 D2A9              SETB    ET0
                                           ; SOURCE LINE # 91
0005 C2AB              CLR     ET1
                                           ; SOURCE LINE # 92
0007 D28C              SETB    TR0
                                           ; SOURCE LINE # 93
0009 C28E              CLR     TR1
                                           ; SOURCE LINE # 94
000B D2AF              SETB    EA
                                           ; SOURCE LINE # 95
000D 22                RET     
             ; FUNCTION pwm_setup (END)

             ; FUNCTION Delay (BEGIN)
                                           ; SOURCE LINE # 98
                                           ; SOURCE LINE # 99
                                           ; SOURCE LINE # 101
;---- Variable 'x' assigned to Register 'R6/R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
0002 FE                MOV     R6,A
0003         ?C0016:
                                           ; SOURCE LINE # 102
0003 0F                INC     R7
0004 BF0001            CJNE    R7,#00H,?C0101
0007 0E                INC     R6
0008         ?C0101:
0008 BE01F8            CJNE    R6,#01H,?C0016
000B BFF4F5            CJNE    R7,#0F4H,?C0016
                                           ; SOURCE LINE # 103
000E         ?C0019:
000E 22                RET     
             ; FUNCTION Delay (END)

             ; FUNCTION SYSTEMCLOCK_Init (BEGIN)
                                           ; SOURCE LINE # 105
                                           ; SOURCE LINE # 107
                                           ; SOURCE LINE # 108
0000 43B203            ORL     OSCICN,#03H
                                           ; SOURCE LINE # 112
0003 E4                CLR     A
0004 F5B9              MOV     CLKMUL,A
                                           ; SOURCE LINE # 115
0006 43B980            ORL     CLKMUL,#080H
                                           ; SOURCE LINE # 116
0009 120000      R     LCALL   Delay
                                           ; SOURCE LINE # 117
000C 43B9C0            ORL     CLKMUL,#0C0H
                                           ; SOURCE LINE # 118
000F 120000      R     LCALL   Delay
0012         ?C0020:
                                           ; SOURCE LINE # 120
0012 E5B9              MOV     A,CLKMUL
0014 30E5FB            JNB     ACC.5,?C0020
0017         ?C0021:
                                           ; SOURCE LINE # 121
0017 75A903            MOV     CLKSEL,#03H
                                           ; SOURCE LINE # 122
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 18  

001A 22                RET     
             ; FUNCTION SYSTEMCLOCK_Init (END)

             ; FUNCTION PORT_Init (BEGIN)
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 125
                                           ; SOURCE LINE # 126
0000 75E101            MOV     XBR0,#01H
                                           ; SOURCE LINE # 127
0003 75E301            MOV     XBR2,#01H
                                           ; SOURCE LINE # 128
0006 75E240            MOV     XBR1,#040H
                                           ; SOURCE LINE # 129
0009 75F1FF            MOV     P0MDIN,#0FFH
                                           ; SOURCE LINE # 130
000C E4                CLR     A
000D F5A4              MOV     P0MDOUT,A
                                           ; SOURCE LINE # 131
000F F5A5              MOV     P1MDOUT,A
                                           ; SOURCE LINE # 132
0011 75F2FF            MOV     P1MDIN,#0FFH
                                           ; SOURCE LINE # 133
0014 43A604            ORL     P2MDOUT,#04H
                                           ; SOURCE LINE # 134
0017 22                RET     
             ; FUNCTION PORT_Init (END)

             ; FUNCTION serial_setup (BEGIN)
                                           ; SOURCE LINE # 136
                                           ; SOURCE LINE # 139
0000 759810            MOV     SCON0,#010H
                                           ; SOURCE LINE # 147
                                           ; SOURCE LINE # 148
0003 758D30            MOV     TH1,#030H
                                           ; SOURCE LINE # 149
0006 538EF4            ANL     CKCON,#0F4H
                                           ; SOURCE LINE # 150
0009 438E08            ORL     CKCON,#08H
                                           ; SOURCE LINE # 151
                                           ; SOURCE LINE # 152
                                           ; SOURCE LINE # 153
                                           ; SOURCE LINE # 154
                                           ; SOURCE LINE # 155
                                           ; SOURCE LINE # 156
                                           ; SOURCE LINE # 157
                                           ; SOURCE LINE # 158
                                           ; SOURCE LINE # 159
                                           ; SOURCE LINE # 160
                                           ; SOURCE LINE # 161
                                           ; SOURCE LINE # 162
000C         ?C0025:
                                           ; SOURCE LINE # 164
000C 858D8B            MOV     TL1,TH1
                                           ; SOURCE LINE # 166
000F 53890F            ANL     TMOD,#0FH
                                           ; SOURCE LINE # 168
0012 438920            ORL     TMOD,#020H
                                           ; SOURCE LINE # 169
0015 D28E              SETB    TR1
                                           ; SOURCE LINE # 170
0017 D299              SETB    TI0
                                           ; SOURCE LINE # 171
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 19  

0019 D2AC              SETB    ES0
                                           ; SOURCE LINE # 172
001B 22                RET     
             ; FUNCTION serial_setup (END)

             ; FUNCTION encoder_setup (BEGIN)
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
0000 75E431            MOV     IT01CF,#031H
                                           ; SOURCE LINE # 176
0003 C288              CLR     IT0
                                           ; SOURCE LINE # 177
0005 C28A              CLR     IT1
                                           ; SOURCE LINE # 178
0007 C289              CLR     IE0
                                           ; SOURCE LINE # 179
0009 C28B              CLR     IE1
                                           ; SOURCE LINE # 180
000B D2A8              SETB    EX0
                                           ; SOURCE LINE # 181
000D D2AA              SETB    EX1
                                           ; SOURCE LINE # 183
000F 22                RET     
             ; FUNCTION encoder_setup (END)

             ; FUNCTION ativa_direita (BEGIN)
                                           ; SOURCE LINE # 185
                                           ; SOURCE LINE # 186
0000 300005      R     JNB     right_wheel_dir,?C0032
                                           ; SOURCE LINE # 187
0003 C292              CLR     P1_2
                                           ; SOURCE LINE # 188
0005 D290              SETB    P1_0
                                           ; SOURCE LINE # 189
0007 22                RET     
0008         ?C0032:
                                           ; SOURCE LINE # 190
                                           ; SOURCE LINE # 191
0008 C290              CLR     P1_0
                                           ; SOURCE LINE # 192
000A D292              SETB    P1_2
                                           ; SOURCE LINE # 193
                                           ; SOURCE LINE # 194
000C         ?C0034:
000C 22                RET     
             ; FUNCTION ativa_direita (END)

             ; FUNCTION desativa_direita (BEGIN)
                                           ; SOURCE LINE # 196
                                           ; SOURCE LINE # 197
0000 C292              CLR     P1_2
                                           ; SOURCE LINE # 198
0002 C290              CLR     P1_0
                                           ; SOURCE LINE # 199
0004 22                RET     
             ; FUNCTION desativa_direita (END)

             ; FUNCTION ativa_esquerda (BEGIN)
                                           ; SOURCE LINE # 201
                                           ; SOURCE LINE # 202
0000 300005      R     JNB     left_wheel_dir,?C0036
                                           ; SOURCE LINE # 203
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 20  

0003 C296              CLR     P1_6
                                           ; SOURCE LINE # 204
0005 D294              SETB    P1_4
                                           ; SOURCE LINE # 205
0007 22                RET     
0008         ?C0036:
                                           ; SOURCE LINE # 206
                                           ; SOURCE LINE # 207
0008 C294              CLR     P1_4
                                           ; SOURCE LINE # 208
000A D296              SETB    P1_6
                                           ; SOURCE LINE # 209
                                           ; SOURCE LINE # 210
000C         ?C0038:
000C 22                RET     
             ; FUNCTION ativa_esquerda (END)

             ; FUNCTION desativa_esquerda (BEGIN)
                                           ; SOURCE LINE # 212
                                           ; SOURCE LINE # 213
0000 C296              CLR     P1_6
                                           ; SOURCE LINE # 214
0002 C294              CLR     P1_4
                                           ; SOURCE LINE # 215
0004 22                RET     
             ; FUNCTION desativa_esquerda (END)

             ; FUNCTION timer0_IT (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C0D0              PUSH    PSW
0008 75D000            MOV     PSW,#00H
000B C007              PUSH    AR7
                                           ; SOURCE LINE # 218
                                           ; SOURCE LINE # 223
000D C28C              CLR     TR0
                                           ; SOURCE LINE # 228
000F 900000      R     MOV     DPTR,#pwm_aux+01H
0012 E0                MOVX    A,@DPTR
0013 04                INC     A
0014 F0                MOVX    @DPTR,A
0015 7006              JNZ     ?C0102
0017 900000      R     MOV     DPTR,#pwm_aux
001A E0                MOVX    A,@DPTR
001B 04                INC     A
001C F0                MOVX    @DPTR,A
001D         ?C0102:
                                           ; SOURCE LINE # 229
001D 900000      R     MOV     DPTR,#pwm_aux
0020 E0                MOVX    A,@DPTR
0021 7004              JNZ     ?C0103
0023 A3                INC     DPTR
0024 E0                MOVX    A,@DPTR
0025 644B              XRL     A,#04BH
0027         ?C0103:
0027 7027              JNZ     ?C0040
                                           ; SOURCE LINE # 231
0029 900000      R     MOV     DPTR,#pwm_left
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E A3                INC     DPTR
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 21  

002F E0                MOVX    A,@DPTR
0030 900000      R     MOV     DPTR,#pwm_left_temp
0033 CF                XCH     A,R7
0034 F0                MOVX    @DPTR,A
0035 A3                INC     DPTR
0036 EF                MOV     A,R7
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 232
0038 900000      R     MOV     DPTR,#pwm_right
003B E0                MOVX    A,@DPTR
003C FF                MOV     R7,A
003D A3                INC     DPTR
003E E0                MOVX    A,@DPTR
003F 900000      R     MOV     DPTR,#pwm_right_temp
0042 CF                XCH     A,R7
0043 F0                MOVX    @DPTR,A
0044 A3                INC     DPTR
0045 EF                MOV     A,R7
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 233
0047 900000      R     MOV     DPTR,#pwm_aux
004A E4                CLR     A
004B F0                MOVX    @DPTR,A
004C A3                INC     DPTR
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 234
004E 8064              SJMP    ?C0041
0050         ?C0040:
                                           ; SOURCE LINE # 235
                                           ; SOURCE LINE # 236
0050 D3                SETB    C
0051 900000      R     MOV     DPTR,#pwm_left_temp+01H
0054 E0                MOVX    A,@DPTR
0055 9400              SUBB    A,#00H
0057 900000      R     MOV     DPTR,#pwm_left_temp
005A E0                MOVX    A,@DPTR
005B 9400              SUBB    A,#00H
005D 4005              JC      ?C0042
                                           ; SOURCE LINE # 237
005F 120000      R     LCALL   ativa_esquerda
                                           ; SOURCE LINE # 238
0062 8003              SJMP    ?C0043
0064         ?C0042:
                                           ; SOURCE LINE # 239
                                           ; SOURCE LINE # 240
0064 120000      R     LCALL   desativa_esquerda
                                           ; SOURCE LINE # 241
0067         ?C0043:
                                           ; SOURCE LINE # 242
0067 D3                SETB    C
0068 900000      R     MOV     DPTR,#pwm_right_temp+01H
006B E0                MOVX    A,@DPTR
006C 9400              SUBB    A,#00H
006E 900000      R     MOV     DPTR,#pwm_right_temp
0071 E0                MOVX    A,@DPTR
0072 9400              SUBB    A,#00H
0074 4005              JC      ?C0044
                                           ; SOURCE LINE # 243
0076 120000      R     LCALL   ativa_direita
                                           ; SOURCE LINE # 244
0079 8003              SJMP    ?C0045
007B         ?C0044:
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 22  

                                           ; SOURCE LINE # 245
                                           ; SOURCE LINE # 246
007B 120000      R     LCALL   desativa_direita
                                           ; SOURCE LINE # 247
007E         ?C0045:
                                           ; SOURCE LINE # 248
007E D3                SETB    C
007F 900000      R     MOV     DPTR,#pwm_left_temp+01H
0082 E0                MOVX    A,@DPTR
0083 9400              SUBB    A,#00H
0085 900000      R     MOV     DPTR,#pwm_left_temp
0088 E0                MOVX    A,@DPTR
0089 9400              SUBB    A,#00H
008B 400C              JC      ?C0046
008D A3                INC     DPTR
008E E0                MOVX    A,@DPTR
008F 24FF              ADD     A,#0FFH
0091 F0                MOVX    @DPTR,A
0092 900000      R     MOV     DPTR,#pwm_left_temp
0095 E0                MOVX    A,@DPTR
0096 34FF              ADDC    A,#0FFH
0098 F0                MOVX    @DPTR,A
0099         ?C0046:
                                           ; SOURCE LINE # 249
0099 D3                SETB    C
009A 900000      R     MOV     DPTR,#pwm_right_temp+01H
009D E0                MOVX    A,@DPTR
009E 9400              SUBB    A,#00H
00A0 900000      R     MOV     DPTR,#pwm_right_temp
00A3 E0                MOVX    A,@DPTR
00A4 9400              SUBB    A,#00H
00A6 400C              JC      ?C0041
00A8 A3                INC     DPTR
00A9 E0                MOVX    A,@DPTR
00AA 24FF              ADD     A,#0FFH
00AC F0                MOVX    @DPTR,A
00AD 900000      R     MOV     DPTR,#pwm_right_temp
00B0 E0                MOVX    A,@DPTR
00B1 34FF              ADDC    A,#0FFH
00B3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 250
00B4         ?C0041:
                                           ; SOURCE LINE # 252
00B4 758A00            MOV     TL0,#00H
                                           ; SOURCE LINE # 253
00B7 C28D              CLR     TF0
                                           ; SOURCE LINE # 254
00B9 D28C              SETB    TR0
                                           ; SOURCE LINE # 255
00BB D007              POP     AR7
00BD D0D0              POP     PSW
00BF D082              POP     DPL
00C1 D083              POP     DPH
00C3 D0E0              POP     ACC
00C5 32                RETI    
             ; FUNCTION timer0_IT (END)

             ; FUNCTION ADC_setup (BEGIN)
                                           ; SOURCE LINE # 257
                                           ; SOURCE LINE # 258
0000 75D108            MOV     REF0CN,#08H
                                           ; SOURCE LINE # 259
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 23  

0003 75BA1F            MOV     AMX0N,#01FH
                                           ; SOURCE LINE # 260
0006 75BC58            MOV     ADC0CF,#058H
                                           ; SOURCE LINE # 261
0009 43BC04            ORL     ADC0CF,#04H
                                           ; SOURCE LINE # 263
000C E4                CLR     A
000D F5BB              MOV     AMX0P,A
                                           ; SOURCE LINE # 264
000F 5391FE            ANL     TMR3CN,#0FEH
                                           ; SOURCE LINE # 265
0012 538E3F            ANL     CKCON,#03FH
                                           ; SOURCE LINE # 266
0015 7594FF            MOV     TMR3L,#0FFH
                                           ; SOURCE LINE # 267
0018 F592              MOV     TMR3RLL,A
                                           ; SOURCE LINE # 268
001A 43E688            ORL     EIE1,#088H
                                           ; SOURCE LINE # 269
001D 759128            MOV     TMR3CN,#028H
                                           ; SOURCE LINE # 270
0020 75E880            MOV     ADC0CN,#080H
                                           ; SOURCE LINE # 271
0023 22                RET     
             ; FUNCTION ADC_setup (END)

             ; FUNCTION interrupt_timer3 (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C0D0              PUSH    PSW
                                           ; SOURCE LINE # 273
                                           ; SOURCE LINE # 277
0008 900000      R     MOV     DPTR,#timer3count
000B E0                MOVX    A,@DPTR
000C B43D10            CJNE    A,#03DH,?C0050
000F A3                INC     DPTR
0010 E0                MOVX    A,@DPTR
0011 B4400B            CJNE    A,#040H,?C0050
                                           ; SOURCE LINE # 278
0014 D2EC              SETB    AD0BUSY
                                           ; SOURCE LINE # 279
0016 900000      R     MOV     DPTR,#timer3count
0019 E4                CLR     A
001A F0                MOVX    @DPTR,A
001B A3                INC     DPTR
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 280
001D 800E              SJMP    ?C0051
001F         ?C0050:
                                           ; SOURCE LINE # 281
001F 900000      R     MOV     DPTR,#timer3count+01H
0022 E0                MOVX    A,@DPTR
0023 04                INC     A
0024 F0                MOVX    @DPTR,A
0025 7006              JNZ     ?C0105
0027 900000      R     MOV     DPTR,#timer3count
002A E0                MOVX    A,@DPTR
002B 04                INC     A
002C F0                MOVX    @DPTR,A
002D         ?C0105:
002D         ?C0051:
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 24  

                                           ; SOURCE LINE # 282
002D 5391BF            ANL     TMR3CN,#0BFH
                                           ; SOURCE LINE # 283
0030 D0D0              POP     PSW
0032 D082              POP     DPL
0034 D083              POP     DPH
0036 D0E0              POP     ACC
0038 32                RETI    
             ; FUNCTION interrupt_timer3 (END)

             ; FUNCTION interrupt_ADC (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C0D0              PUSH    PSW
0008 75D000            MOV     PSW,#00H
000B C007              PUSH    AR7
                                           ; SOURCE LINE # 285
                                           ; SOURCE LINE # 286
000D 900000      R     MOV     DPTR,#sensorCount
0010 E0                MOVX    A,@DPTR
0011 14                DEC     A
0012 6015              JZ      ?C0055
0014 14                DEC     A
0015 6017              JZ      ?C0056
0017 14                DEC     A
0018 6019              JZ      ?C0057
001A 14                DEC     A
001B 601B              JZ      ?C0058
001D 14                DEC     A
001E 601D              JZ      ?C0059
0020 2405              ADD     A,#05H
0022 701E              JNZ     ?C0053
                                           ; SOURCE LINE # 287
0024         ?C0054:
                                           ; SOURCE LINE # 288
0024 75BB01            MOV     AMX0P,#01H
                                           ; SOURCE LINE # 289
0027 8019              SJMP    ?C0053
                                           ; SOURCE LINE # 290
0029         ?C0055:
                                           ; SOURCE LINE # 291
0029 75BB02            MOV     AMX0P,#02H
                                           ; SOURCE LINE # 292
002C 8014              SJMP    ?C0053
                                           ; SOURCE LINE # 293
002E         ?C0056:
                                           ; SOURCE LINE # 294
002E 75BB03            MOV     AMX0P,#03H
                                           ; SOURCE LINE # 295
0031 800F              SJMP    ?C0053
                                           ; SOURCE LINE # 296
0033         ?C0057:
                                           ; SOURCE LINE # 297
0033 75BB04            MOV     AMX0P,#04H
                                           ; SOURCE LINE # 298
0036 800A              SJMP    ?C0053
                                           ; SOURCE LINE # 299
0038         ?C0058:
                                           ; SOURCE LINE # 300
0038 75BB05            MOV     AMX0P,#05H
                                           ; SOURCE LINE # 301
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 25  

003B 8005              SJMP    ?C0053
                                           ; SOURCE LINE # 302
003D         ?C0059:
                                           ; SOURCE LINE # 303
003D 75BB00            MOV     AMX0P,#00H
                                           ; SOURCE LINE # 304
0040 D200        R     SETB    new_conversion_flag
                                           ; SOURCE LINE # 305
                                           ; SOURCE LINE # 306
0042         ?C0053:
                                           ; SOURCE LINE # 307
0042 900000      R     MOV     DPTR,#sensorCount
0045 E0                MOVX    A,@DPTR
0046 FF                MOV     R7,A
0047 2400        R     ADD     A,#LOW sensor_values
0049 F582              MOV     DPL,A
004B E4                CLR     A
004C 3400        R     ADDC    A,#HIGH sensor_values
004E F583              MOV     DPH,A
0050 E5BE              MOV     A,ADC0H
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 308
0053 EF                MOV     A,R7
0054 B40506            CJNE    A,#05H,?C0060
                                           ; SOURCE LINE # 309
0057 900000      R     MOV     DPTR,#sensorCount
005A 74FF              MOV     A,#0FFH
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 310
005D         ?C0060:
                                           ; SOURCE LINE # 311
005D 900000      R     MOV     DPTR,#sensorCount
0060 E0                MOVX    A,@DPTR
0061 04                INC     A
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 312
0063 E0                MOVX    A,@DPTR
0064 6002              JZ      ?C0061
0066 D2EC              SETB    AD0BUSY
0068         ?C0061:
                                           ; SOURCE LINE # 313
0068 C2ED              CLR     AD0INT
                                           ; SOURCE LINE # 314
006A D007              POP     AR7
006C D0D0              POP     PSW
006E D082              POP     DPL
0070 D083              POP     DPH
0072 D0E0              POP     ACC
0074 32                RETI    
             ; FUNCTION interrupt_ADC (END)

             ; FUNCTION send_distances_info (BEGIN)
                                           ; SOURCE LINE # 316
                                           ; SOURCE LINE # 321
;---- Variable 'indice' assigned to Register 'R6' ----
0000 E4                CLR     A
0001 FE                MOV     R6,A
0002         ?C0063:
                                           ; SOURCE LINE # 322
0002 EE                MOV     A,R6
0003 2422              ADD     A,#022H
0005 900000      R     MOV     DPTR,#command
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 26  

0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 323
0009 7400        R     MOV     A,#LOW sensor_values
000B 2E                ADD     A,R6
000C F582              MOV     DPL,A
000E E4                CLR     A
000F 3400        R     ADDC    A,#HIGH sensor_values
0011 F583              MOV     DPH,A
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 7004              JNZ     ?C0066
0017 7D01              MOV     R5,#01H
0019 8002              SJMP    ?C0067
001B         ?C0066:
001B 7D00              MOV     R5,#00H
001D         ?C0067:
001D EF                MOV     A,R7
001E 2D                ADD     A,R5
001F 900000      R     MOV     DPTR,#command+01H
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 324
0023 A3                INC     DPTR
0024 74FE              MOV     A,#0FEH
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 325
0027 A3                INC     DPTR
0028 740A              MOV     A,#0AH
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 326
;---- Variable 'indice2' assigned to Register 'R7' ----
002B E4                CLR     A
002C FF                MOV     R7,A
002D         ?C0068:
002D         ?C0071:
                                           ; SOURCE LINE # 327
002D 3000FD      R     JNB     flag_send,?C0071
0030         ?C0072:
                                           ; SOURCE LINE # 328
0030 C200        R     CLR     flag_send
                                           ; SOURCE LINE # 329
0032 7400        R     MOV     A,#LOW command
0034 2F                ADD     A,R7
0035 F582              MOV     DPL,A
0037 E4                CLR     A
0038 3400        R     ADDC    A,#HIGH command
003A F583              MOV     DPH,A
003C E0                MOVX    A,@DPTR
003D F599              MOV     SBUF0,A
                                           ; SOURCE LINE # 330
003F 0F                INC     R7
0040 EF                MOV     A,R7
0041 B404E9            CJNE    A,#04H,?C0068
                                           ; SOURCE LINE # 331
0044         ?C0065:
0044 0E                INC     R6
0045 EE                MOV     A,R6
0046 B406B9            CJNE    A,#06H,?C0063
                                           ; SOURCE LINE # 332
0049         ?C0073:
0049 22                RET     
             ; FUNCTION send_distances_info (END)

C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 27  

             ; FUNCTION send_encoders_info (BEGIN)
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 338
;---- Variable 'iencoder' assigned to Register 'R5' ----
0000 E4                CLR     A
0001 FD                MOV     R5,A
0002         ?C0074:
                                           ; SOURCE LINE # 339
0002 ED                MOV     A,R5
0003 2420              ADD     A,#020H
0005 900000      R     MOV     DPTR,#command
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 340
0009 ED                MOV     A,R5
000A 25E0              ADD     A,ACC
000C 2400        R     ADD     A,#LOW encoder_count
000E F582              MOV     DPL,A
0010 E4                CLR     A
0011 3400        R     ADDC    A,#HIGH encoder_count
0013 F583              MOV     DPH,A
0015 E0                MOVX    A,@DPTR
0016 FA                MOV     R2,A
0017 A3                INC     DPTR
0018 E0                MOVX    A,@DPTR
0019 FB                MOV     R3,A
001A EA                MOV     A,R2
001B 900000      R     MOV     DPTR,#command+01H
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 341
001F EB                MOV     A,R3
0020 A3                INC     DPTR
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 342
0022 A3                INC     DPTR
0023 74FE              MOV     A,#0FEH
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 343
0026 A3                INC     DPTR
0027 740A              MOV     A,#0AH
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 344
;---- Variable 'indice' assigned to Register 'R7' ----
002A E4                CLR     A
002B FF                MOV     R7,A
002C         ?C0077:
002C         ?C0080:
                                           ; SOURCE LINE # 345
002C 3000FD      R     JNB     flag_send,?C0080
002F         ?C0081:
                                           ; SOURCE LINE # 346
002F C200        R     CLR     flag_send
                                           ; SOURCE LINE # 347
0031 7400        R     MOV     A,#LOW command
0033 2F                ADD     A,R7
0034 F582              MOV     DPL,A
0036 E4                CLR     A
0037 3400        R     ADDC    A,#HIGH command
0039 F583              MOV     DPH,A
003B E0                MOVX    A,@DPTR
003C F599              MOV     SBUF0,A
                                           ; SOURCE LINE # 348
003E 0F                INC     R7
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 28  

003F EF                MOV     A,R7
0040 B405E9            CJNE    A,#05H,?C0077
                                           ; SOURCE LINE # 349
0043         ?C0076:
0043 0D                INC     R5
0044 ED                MOV     A,R5
0045 B402BA            CJNE    A,#02H,?C0074
                                           ; SOURCE LINE # 350
0048         ?C0082:
0048 22                RET     
             ; FUNCTION send_encoders_info (END)

             ; FUNCTION interrupt_encoder_right (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
                                           ; SOURCE LINE # 353
                                           ; SOURCE LINE # 355
0006 900000      R     MOV     DPTR,#encoder_count+01H
0009 E0                MOVX    A,@DPTR
000A 04                INC     A
000B F0                MOVX    @DPTR,A
000C 7006              JNZ     ?C0106
000E 900000      R     MOV     DPTR,#encoder_count
0011 E0                MOVX    A,@DPTR
0012 04                INC     A
0013 F0                MOVX    @DPTR,A
0014         ?C0106:
                                           ; SOURCE LINE # 356
0014 C289              CLR     IE0
                                           ; SOURCE LINE # 357
0016 D082              POP     DPL
0018 D083              POP     DPH
001A D0E0              POP     ACC
001C 32                RETI    
             ; FUNCTION interrupt_encoder_right (END)

             ; FUNCTION interrupt_encoder_left (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
                                           ; SOURCE LINE # 359
                                           ; SOURCE LINE # 361
0006 900000      R     MOV     DPTR,#encoder_count+03H
0009 E0                MOVX    A,@DPTR
000A 04                INC     A
000B F0                MOVX    @DPTR,A
000C 7006              JNZ     ?C0107
000E 900000      R     MOV     DPTR,#encoder_count+02H
0011 E0                MOVX    A,@DPTR
0012 04                INC     A
0013 F0                MOVX    @DPTR,A
0014         ?C0107:
                                           ; SOURCE LINE # 362
0014 C28B              CLR     IE1
                                           ; SOURCE LINE # 363
0016 D082              POP     DPL
0018 D083              POP     DPH
001A D0E0              POP     ACC
001C 32                RETI    
             ; FUNCTION interrupt_encoder_left (END)

C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 29  

             ; FUNCTION interrupt_serial (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C0D0              PUSH    PSW
0008 75D000            MOV     PSW,#00H
000B C006              PUSH    AR6
000D C007              PUSH    AR7
                                           ; SOURCE LINE # 365
                                           ; SOURCE LINE # 367
000F 30985B            JNB     RI0,?C0085
                                           ; SOURCE LINE # 368
0012 900000      R     MOV     DPTR,#indice
0015 E0                MOVX    A,@DPTR
0016 FE                MOV     R6,A
0017 A3                INC     DPTR
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A 2400        R     ADD     A,#LOW rec_command
001C F582              MOV     DPL,A
001E 7400        R     MOV     A,#HIGH rec_command
0020 3E                ADDC    A,R6
0021 F583              MOV     DPH,A
0023 E599              MOV     A,SBUF0
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 369
0026 7400        R     MOV     A,#LOW rec_command
0028 2F                ADD     A,R7
0029 F582              MOV     DPL,A
002B 7400        R     MOV     A,#HIGH rec_command
002D 3E                ADDC    A,R6
002E F583              MOV     DPH,A
0030 E0                MOVX    A,@DPTR
0031 640A              XRL     A,#0AH
0033 600C              JZ      ?C0087
0035 900000      R     MOV     DPTR,#indice
0038 E0                MOVX    A,@DPTR
0039 7004              JNZ     ?C0108
003B A3                INC     DPTR
003C E0                MOVX    A,@DPTR
003D 6405              XRL     A,#05H
003F         ?C0108:
003F 701C              JNZ     ?C0086
0041         ?C0087:
                                           ; SOURCE LINE # 370
0041 900000      R     MOV     DPTR,#indice
0044 E0                MOVX    A,@DPTR
0045 FE                MOV     R6,A
0046 A3                INC     DPTR
0047 E0                MOVX    A,@DPTR
0048 2400        R     ADD     A,#LOW rec_command
004A F582              MOV     DPL,A
004C 7400        R     MOV     A,#HIGH rec_command
004E 3E                ADDC    A,R6
004F F583              MOV     DPH,A
0051 E4                CLR     A
0052 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 371
0053 900000      R     MOV     DPTR,#indice
0056 F0                MOVX    @DPTR,A
0057 A3                INC     DPTR
0058 F0                MOVX    @DPTR,A
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 30  

                                           ; SOURCE LINE # 372
0059 D200        R     SETB    new_cmd_flag
                                           ; SOURCE LINE # 373
005B 800E              SJMP    ?C0088
005D         ?C0086:
                                           ; SOURCE LINE # 374
005D 900000      R     MOV     DPTR,#indice+01H
0060 E0                MOVX    A,@DPTR
0061 04                INC     A
0062 F0                MOVX    @DPTR,A
0063 7006              JNZ     ?C0109
0065 900000      R     MOV     DPTR,#indice
0068 E0                MOVX    A,@DPTR
0069 04                INC     A
006A F0                MOVX    @DPTR,A
006B         ?C0109:
006B         ?C0088:
                                           ; SOURCE LINE # 375
006B C298              CLR     RI0
                                           ; SOURCE LINE # 376
006D         ?C0085:
                                           ; SOURCE LINE # 378
006D 309904            JNB     TI0,?C0090
                                           ; SOURCE LINE # 379
0070 C299              CLR     TI0
                                           ; SOURCE LINE # 380
0072 D200        R     SETB    flag_send
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 383
0074         ?C0090:
0074 D007              POP     AR7
0076 D006              POP     AR6
0078 D0D0              POP     PSW
007A D082              POP     DPL
007C D083              POP     DPH
007E D0E0              POP     ACC
0080 32                RETI    
             ; FUNCTION interrupt_serial (END)

             ; FUNCTION main (BEGIN)
                                           ; SOURCE LINE # 384
                                           ; SOURCE LINE # 386
0000 53D9BF            ANL     PCA0MD,#0BFH
                                           ; SOURCE LINE # 388
0003 120000      R     LCALL   SYSTEMCLOCK_Init
                                           ; SOURCE LINE # 389
0006 120000      R     LCALL   PORT_Init
                                           ; SOURCE LINE # 391
0009 120000      R     LCALL   serial_setup
                                           ; SOURCE LINE # 392
000C 120000      R     LCALL   pwm_setup
                                           ; SOURCE LINE # 393
000F 120000      R     LCALL   encoder_setup
                                           ; SOURCE LINE # 395
0012 120000      R     LCALL   ADC_setup
                                           ; SOURCE LINE # 396
0015 D2AF              SETB    EA
                                           ; SOURCE LINE # 400
0017 C200        R     CLR     left_wheel_dir
                                           ; SOURCE LINE # 401
0019 C200        R     CLR     right_wheel_dir
001B         ?C0091:
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 31  

                                           ; SOURCE LINE # 403
                                           ; SOURCE LINE # 413
001B 3000FD      R     JNB     new_cmd_flag,?C0091
                                           ; SOURCE LINE # 418
001E C200        R     CLR     new_cmd_flag
                                           ; SOURCE LINE # 419
0020 900000      R     MOV     DPTR,#rec_command
0023 E0                MOVX    A,@DPTR
0024 245F              ADD     A,#05FH
0026 6028              JZ      ?C0096
0028 24F1              ADD     A,#0F1H
002A 6054              JZ      ?C0098
002C 24B1              ADD     A,#0B1H
002E 6041              JZ      ?C0097
0030 245F              ADD     A,#05FH
0032 70E7              JNZ     ?C0091
                                           ; SOURCE LINE # 420
0034         ?C0095:
                                           ; SOURCE LINE # 424
0034 900000      R     MOV     DPTR,#rec_command+01H
0037 E0                MOVX    A,@DPTR
0038 FF                MOV     R7,A
0039 33                RLC     A
003A 9200        R     MOV     left_wheel_dir,C
                                           ; SOURCE LINE # 425
003C EF                MOV     A,R7
003D 547F              ANL     A,#07FH
003F FF                MOV     R7,A
0040 33                RLC     A
0041 95E0              SUBB    A,ACC
0043 FE                MOV     R6,A
0044 7C00              MOV     R4,#00H
0046 7D05              MOV     R5,#05H
0048 120000      E     LCALL   ?C?IMUL
004B 900000      R     MOV     DPTR,#pwm_left
                                           ; SOURCE LINE # 426
004E 801A              SJMP    ?C0110
                                           ; SOURCE LINE # 427
0050         ?C0096:
                                           ; SOURCE LINE # 431
0050 900000      R     MOV     DPTR,#rec_command+01H
0053 E0                MOVX    A,@DPTR
0054 FF                MOV     R7,A
0055 33                RLC     A
0056 9200        R     MOV     right_wheel_dir,C
                                           ; SOURCE LINE # 432
0058 EF                MOV     A,R7
0059 547F              ANL     A,#07FH
005B FF                MOV     R7,A
005C 33                RLC     A
005D 95E0              SUBB    A,ACC
005F FE                MOV     R6,A
0060 7C00              MOV     R4,#00H
0062 7D05              MOV     R5,#05H
0064 120000      E     LCALL   ?C?IMUL
0067 900000      R     MOV     DPTR,#pwm_right
006A         ?C0110:
006A EE                MOV     A,R6
006B F0                MOVX    @DPTR,A
006C A3                INC     DPTR
006D EF                MOV     A,R7
006E F0                MOVX    @DPTR,A
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 32  

                                           ; SOURCE LINE # 433
006F 80AA              SJMP    ?C0091
                                           ; SOURCE LINE # 435
0071         ?C0097:
                                           ; SOURCE LINE # 436
0071 E4                CLR     A
0072 900000      R     MOV     DPTR,#pwm_left
0075 F0                MOVX    @DPTR,A
0076 A3                INC     DPTR
0077 F0                MOVX    @DPTR,A
0078 900000      R     MOV     DPTR,#pwm_right
007B F0                MOVX    @DPTR,A
007C A3                INC     DPTR
007D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 440
007E 809B              SJMP    ?C0091
                                           ; SOURCE LINE # 441
0080         ?C0098:
                                           ; SOURCE LINE # 442
0080 120000      R     LCALL   send_distances_info
                                           ; SOURCE LINE # 443
0083 120000      R     LCALL   send_encoders_info
                                           ; SOURCE LINE # 444
0086 8093              SJMP    ?C0091
             ; FUNCTION main (END)

C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 33  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
TMOD . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0089H  1
TL0. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008AH  1
TL1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008BH  1
TH1. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008DH  1
CKCON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   008EH  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
TMR3CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0091H  1
TMR3RLL. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0092H  1
TMR3L. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0094H  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
P0MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A4H  1
P1MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A5H  1
P2MDOUT. . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A6H  1
CLKSEL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A9H  1
OSCICN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B2H  1
CLKMUL . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B9H  1
AMX0N. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BAH  1
AMX0P. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BBH  1
ADC0CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BCH  1
ADC0H. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00BEH  1
REF0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D1H  1
SCON1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D2H  1
SBUF1. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D3H  1
PCA0MD . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D9H  1
XBR0 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E1H  1
XBR1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E2H  1
XBR2 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E3H  1
IT01CF . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E4H  1
EIE1 . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E6H  1
ADC0CN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
P0MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F1H  1
P1MDIN . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F2H  1
TR1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008EH  1
TF0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008DH  1
TR0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008CH  1
IE1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008BH  1
IT1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      008AH  1
IE0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0089H  1
IT0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0088H  1
TI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
RI0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0098H  1
EA . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AFH  1
ES0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ACH  1
ET1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ABH  1
EX1. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00AAH  1
ET0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A9H  1
EX0. . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00A8H  1
AD0INT . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00EDH  1
AD0BUSY. . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      00ECH  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
P1_0 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0090H  1
P1_2 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0092H  1
P1_4 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0094H  1
P1_6 . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0096H  1
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 34  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


pwm_right. . . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0008H  2
pwm_left . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    000AH  2
sensorCount. . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   000CH  1
sensor_values. . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    000DH  6
new_conversion_flag. . . . . . . . . .  PUBLIC   DATA   BIT      0000H  1
new_cmd_flag . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0001H  1
timer3count. . . . . . . . . . . . . .  PUBLIC   XDATA  U_INT    0013H  2
Rx_Buff. . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0015H  1
Tx_Buff. . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   0016H  1
sentido. . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0002H  1
flag_send. . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0003H  1
left_wheel_dir . . . . . . . . . . . .  PUBLIC   DATA   BIT      0004H  1
right_wheel_dir. . . . . . . . . . . .  PUBLIC   DATA   BIT      0005H  1
rec_command. . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0017H  8
i. . . . . . . . . . . . . . . . . . .  PUBLIC   XDATA  U_CHAR   001FH  1
UART . . . . . . . . . . . . . . . . .  PUBLIC   DATA   BIT      0006H  1
encoder_count. . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0020H  4
_putchar . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  c. . . . . . . . . . . . . . . . . .  * REG *  DATA   CHAR     0007H  1
pwm_setup. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
Delay. . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  x. . . . . . . . . . . . . . . . . .  * REG *  DATA   INT      0006H  2
SYSTEMCLOCK_Init . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
PORT_Init. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
serial_setup . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
encoder_setup. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ativa_direita. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
desativa_direita . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
ativa_esquerda . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
desativa_esquerda. . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
timer0_IT. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  pwm_aux. . . . . . . . . . . . . . .  STATIC   XDATA  U_INT    0000H  2
  pwm_left_temp. . . . . . . . . . . .  STATIC   XDATA  U_INT    0002H  2
  pwm_right_temp . . . . . . . . . . .  STATIC   XDATA  U_INT    0004H  2
ADC_setup. . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
interrupt_timer3 . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
interrupt_ADC. . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
send_distances_info. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  command. . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0000H  4
  indice . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
  indice2. . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
send_encoders_info . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  command. . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0000H  5
  indice . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
  iencoder . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
interrupt_encoder_right. . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
interrupt_encoder_left . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
interrupt_serial . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  indice . . . . . . . . . . . . . . .  STATIC   XDATA  INT      0006H  2
main . . . . . . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1090    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     36       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V8.18   MAIN                                                                  11/10/2011 15:17:08 PAGE 35  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      7    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
